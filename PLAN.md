# EAV Plugin 5.x Migration & Feature Plan (Source of Truth)

This file is the living, versioned plan for upgrading and evolving the EAV plugin. Do not diverge from this plan without updating this file via PR.

Version: v1.0 (initial consolidated plan)
Owner: ProtechPartsApp Persona
Scope: CakePHP 2.x to 5.x migration (no changes to 2.x), full TypeFactory coverage, interactive setup, DB-agnostic behavior, and UI scaffolding.

High-level principles
- Single family of EAV value tables per install (no PK suffix in table/table-class names).
- Canonical naming:
  - Tables: eav_<type> (e.g., eav_string, eav_json, eav_decimal, eav_fk).
  - PHP Tables: Eav<Model>Table (e.g., EavStringTable, EavJsonTable).
- Field names:
  - Always use entity_id (UUID or INT based on setup selection).
  - Use value (not val) for the attribute’s stored value column.
- Full TypeFactory coverage with sensible defaults; advanced types are opt-in during setup.
- Interactive Setup Command: prompt for connection, PK type, UUID subtype (if uuid), JSON column storage (json/jsonb guarded by driver), output mode (Migrations or raw SQL), jsonEncodeOnWrite, and type selection (defaults + optional).
- DB-agnostic by default; detect default datasource/driver; guard Postgres-only features automatically.
- Configuration persistence: save setup answers to a durable configuration (file and/or DB), and stamp migrations/SQL with the chosen settings.

Glossary
- JSON Attribute: an attribute whose data_type is json, stored in eav_json.value (column type json/jsonb per DB/choice).
- JSON Storage (Entity JSON bundle): storing all attributes for a single entity row in one JSON/JSONB column in the entity’s own table (e.g., engines.attrs, parts.spec). This is a storage mode alternative to typed EAV tables and is configured per application table via behavior options.

Formatting Guidelines
- Single-block-per-file MUST
- Use a single SEARCH/REPLACE block per edited file
- No mixed full-file + search/replace in the same message
- No split/continued blocks; ask to continue if too large
- Add a short mirror in Instructions:
- “Follow the Formatting Guidelines; they are mandatory.”

## Feature 1 — Cleanup/Hardening (Done)
What’s drifting
- Value tables and classes currently use Av* and pk suffixes (e.g., av_string_uuid/av_string_int) and class resolution uses pk suffixes: see [EavBehavior#avTableClass](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#avTableClass) and [EavBehavior#pkSuffix](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#pkSuffix).
- JSONB naming drift in class/name composition (Json vs Jsonb): [EavBehavior#tableTypeSegment](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#tableTypeSegment).
- Static SQL snapshots under config/Migrations don’t align with canonical direction.

Realignment
- Adopt canonical naming: eav_* tables and Eav* tables classes (no pk suffix).
- Unify entity_id for both PK families; integer PK uses integer type for entity_id.
- Rename val column to value in all schemas, models, and behavior code.
- Remove config/Migrations/*.sql legacy snapshots. All schema is generated by Setup (Migrations or raw SQL).
- Configuration persistence (Setup answers):
  - Preferred: plugins/Eav/config/eav.json (JSON file) with all choices (connection, pkType, uuidSubtype, jsonStorage, jsonEncodeOnWrite, selected types, output mode).
  - Optionally: eav_settings table for multi-node deployments; not required initially.
  - Stamp generated migrations/SQL with a header comment summarizing chosen options.

Acceptanced
- Behavior resolves to Eav* classes and eav_* tables.
- Entity ID field is always entity_id; column type matches configured PK family.
- Value column is value across all code and schema.
- No dependency on Av* names or *_uuid/_int tables.

Summary and Confirmation
- Summary of changes for Feature 1 (Cleanup/Hardening)
  Behavior updates
  Canonical naming and resolution implemented in EavBehavior:
  avTableClass resolves to Eav* classes mapped to eav_* tables (no PK suffix dependency).
  Unified entity ID field via entityIdField to always use entity_id (type varies by PK family).
  Switched from val to value across reads/writes (saveEavValue, fetchEavValues, findByAttribute).
  JSON naming canonicalized to the “Json” segment; added jsonEncodeOnWrite gating for write-time JSON encoding.

- Setup command hardening
  Canonical schema generation in EavSetupCommand:
  Generates eav_* tables (e.g., eav_string, eav_json).
  Always uses entity_id; column type based on configured PK family (UUID subtype or BIGINT).
  Uses value column consistently; eav_json.value uses json or jsonb per driver and choice.
  Limits default scaffolded types to a safe baseline; advanced/geospatial types deferred to Feature 2.
  Migration naming conflict guidance given; resolved by removing the older migration or using a unique --name.
  JSONB migrator fixes

- EavMigrateJsonbToEavCommand:
  Replaced the Postgres “?” operator with jsonb_exists(...) to avoid PDO “?” placeholder conflicts.
  Continues to guard for Postgres-only features and uses the behavior to persist EAV values.
  Added files (new)
  EavStringTable.php: Maps to eav_string.
  EavJsonTable.php: Maps to eav_json.
  EavStringFixture.php: eav_string with value column.
  EavJsonFixture.php: eav_json with value column.

- Modified files
  EavBehavior.php: Canonical resolution, unified entity_id, value column, JSON gating.
  EavSetupCommand.php: Canonical eav_* tables, entity_id, value column; safe default types.
  EavMigrateJsonbToEavCommand.php: jsonb_exists fix for queries.
  EavBehaviorTest.php: Updated fixtures to Eav*; added setUpBeforeClass to ensure attributes, eav_string, and eav_json exist in test DB; expectations updated for canonical JSON class resolution and value column.
  EavSetupCommandTest.php: Verifies dry-run output and presence of attributes/attribute_sets in migration.
  EavMigrateJsonbToEavCommandTest.php: Adjusted TRUNCATE to include attribute_set_attributes and CASCADE to satisfy FK constraints, and updated to eav_string/value. (File not shown above, but this change was applied during test stabilization.)

- Deleted files (by you)
  Legacy Av* Table classes under plugins/Eav/src/Model/Table (e.g., AvStringUuidTable.php, AvJsonUuidTable.php, AvStringIntTable.php, etc.).
  Legacy Av* fixtures under plugins/Eav/tests/Fixture.
  Legacy SQL snapshots under plugins/Eav/config/Migrations/*.sql.
  What intentionally remains unchanged in Feature 1
  Core tables for attributes and sets remain unprefixed: attributes, attribute_sets, attribute_set_attributes. Prefixing and junction model conventions are planned for Feature 5 per PLAN.md.

- Commands used during this work
  Generate migration for test connection:
  bin/cake eav setup --pk-type uuid --uuid-type uuid --json-storage json --connection test
  Apply plugin migrations to test DB:
  bin/cake migrations migrate -p Eav -c test
  Run PHPUnit test suites:
  vendor/bin/phpunit plugins/Eav/tests
  vendor/bin/phpunit plugins/Eav/tests/TestCase/Model/Behavior/EavBehaviorTest.php
  vendor/bin/phpunit plugins/Eav/tests/TestCase/Command/EavSetupCommandTest.php
  vendor/bin/phpunit plugins/Eav/tests/TestCase/Command/EavMigrateJsonbToEavCommandTest.php
  Outcome
  All Feature 1 acceptance criteria are met: Behavior/table resolution is canonical (Eav*/eav_), entity_id is unified, value column is consistent, and Av dependencies and legacy SQL snapshots are removed. Prefixing of core attribute/attribute set tables is deferred to Feature 5 as planned.

Confirmation against acceptance
  - "Behavior resolves to Eav* classes and eav_* tables: Yes.
  Class resolution via avTableClass now returns Eav.* classes (no PK suffix) and canonicalizes JSON to EavJson.
  Corresponding Eav* Table classes are in place (tests passed), so resolution maps to eav_* tables correctly.
  Entity ID field is always entity_id; type matches PK family: Yes.
  Behavior returns entity_id from entityIdField.
  Setup generates entity_id with the proper type in buildMigration (UUID subtype or BIGINT).
  Value column is value across all code and schema: Yes.
  Behavior writes/reads value in saveEavValue, fetchEavValues, and findByAttribute.
  Setup generates value columns in buildMigration.
  No dependency on Av* names or *_uuid/_int tables: Yes.
  Av* classes/fixtures were removed by you; tests use Eav* and eav_* exclusively and now pass.
  JSONB migrator fixed to avoid “?” placeholder issues using jsonb_exists() in execute.
  Static SQL snapshots removed: Yes (you deleted them).
  Notes/deferrals per PLAN
  Attributes/AttributeSets tables remain unprefixed and the join table remains attribute_set_attributes by design; prefixing is scheduled in Feature 5 (see plugins/Eav/PLAN.md).
  Configuration persistence to plugins/Eav/config/eav.json and interactive setup are planned for Feature 4; not required in Feature 1."

## Feature 2 — Data Type Support
Goals
- Support all CakePHP TypeFactory types + custom ‘fk’.
- Default set most apps need; advanced types are opt-in via interactive Setup.
- Single eav_fk table: value type depends on PK family (UUID subtype or BIGINT), but name and schema remain canonical.

Defaults (pre-selected in Setup)
- string, text, integer, smallinteger, tinyinteger, biginteger, decimal, float, boolean, date, datetime, time, json, uuid, binaryuuid, nativeuuid, fk

Optional/Advanced (opt-in during Setup)
- char, binary, enum (string-limited), timestamp, datetimefractional, timestampfractional, timestamptimezone
- geometry, point, linestring, polygon (only if DB/extension supports)
Notes:
- All selected types get a dedicated table Eav* + eav_<type>. For rare/custom types not selected, dynamic tables are supported but documented as possibly less performant.

Acceptance
- Setup scaffolds only the selected set (defaults + optional).
- [EavBehavior#isSupportedType](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#isSupportedType) validates using TypeFactory + custom types.

Summary and Confirmation
  - Summary of work completed for Feature 2 (Data Type Support + single eav_fk)
      - Goals met:
        - Unified custom foreign key type to fk with a single canonical eav_fk table; value type follows chosen PK family (uuid subtype or biginteger).
        - Setup command now scaffolds only selected types (defaults/all/CSV via --types) with TypeFactory validation and alias normalization (e.g., fk_uuid/fk_int -> fk).
        - Behavior validates types via TypeFactory plus custom types, resolves tables dynamically when no Eav*Table class exists, and casts fk according to pkType.
        - JSONB migration command hardened with connection selection, source-table existence guard, and jsonb_exists filter.

  - Key changes
    - Setup generator
    - Added --types selection and alias normalization; defaults exclude timestamp (advanced types remain opt-in).
    - Special-cased fk to emit eav_fk with PK-family value type.
    - For json, always uses eav_json; column type is json or jsonb per driver/flag.
    - Updated generator to emit addTimestamps('created','modified') for all eav_* tables to prevent NOT NULL violations when dynamic tables are used without a Timestamp behavior. Regenerate your migration via the command to apply this.

  - Behavior
    - Added back-compat aliases fk_uuid/fk_int -> fk and support for unified fk in casting.
    - Dynamic fallback in table resolution (uses a generic Table targeting eav_  when no Eav*Table class exists).
    - Validation through TypeFactory map and custom 'fk'.

  - JSONB migrator
    - Added --connection flag and consistent use for reads/writes.
    - Guards: Postgres-only, verifies source table exists on connection with a clear error if missing.
    - Uses jsonb_exists with ::jsonb cast for json columns; saves using normalized types.

  - Tests
    - Added/used JsonEntitiesFixture for source data; stabilized EavMigrateJsonbToEavCommandTest to operate on the test datasource and json_entities table.
    - Kept setUpBeforeClass bootstraps where other tests depend on schema presence; added missing TableSchema import.
    - All tests pass.

  - Files touched
    - Commands
      - EavSetupCommand.php --types option (defaults|all|CSV); resolveSelectedTypes; fk special-casing in buildMigration; json storage handling; addTimestamps in eav_* loop.
      - EavCreateAttributeCommand.php normalizeType: jsonb->json; fk_uuid/fk_int->fk; TypeFactory validation.
      - EavMigrateJsonbToEavCommand.php --connection option; connection-aware table access; source table existence check; jsonb_exists with ::jsonb cast; saves using normalized type.

  - Behavior
    - EavBehavior.php
      - typeAliases includes fk_uuid/fk_int -> fk; customTypes includes fk; isSupportedType uses TypeFactory; tableFor dynamic fallback; castValueForType handles fk by pkType.

  - Tables/Entities (no structural changes beyond existing)
    - EavStringTable.php, EavJsonTable.php AttributesTable.php, Attribute.php

  - Tests and fixtures
    - JsonEntitiesFixture.php (source json_entities table)
    - AttributesFixture.php, EavStringFixture.php, EavJsonFixture.php
    - EavMigrateJsonbToEavCommandTest.php (uses test connection and json_entities; added TableSchema import; kept setUpBeforeClass)
    - EavCreateAttributeCommandTest.php, EavSetupCommandTest.php
    - EavBehaviorTest.php

  - Migration
    The latest committed migration file exists: config/Migrations/20251221070031_eav_setup.php. After updating the generator (EavSetupCommand), regenerate a new migration so eav_* tables use addTimestamps in the loop.

  - Commands executed and expected
    - Setup (dry-run):
      - bin/cake eav setup --dry-run --pk-type uuid --uuid-type uuid --json-storage json --connection test

  - Apply migrations to test DB:
    - bin/cake migrations migrate -p Eav -c test
  - JSONB migrator (test):
    - bin/cake eav migrate_jsonb_to_eav json_entities data --attribute color --type string --dry-run --connection test
    - bin/cake eav migrate_jsonb_to_eav json_entities data --attribute color --type string --connection test

  - PHPUnit:
    - vendor/bin/phpunit plugins/Eav/tests (or targeted files as needed)

  - Schema and configuration updates
    - Generator now emits addTimestamps for all eav_* tables (attributes and set tables already used addTimestamps). Regenerate the migration via the setup command; avoid hand-editing generated files.
    - Unified single eav_fk table; canonical eav_* names used throughout.
    - Optional: Refresh schema-dump lock files to remove legacy av_* and fk_uuid/fk_int artifacts for clarity.

  - PR checklist (per AGENTS.md)
    - Work completed:
      - fk unification, type selection via --types in setup, generator emits addTimestamps in eav_* loop, behavior validation and dynamic resolution, JSONB migrator connection handling and guard.

    - Commands executed:
      - As listed above (setup dry-run, migrations migrate -p Eav -c test, JSONB migrator, PHPUnit).

    - Table counts added:
      - Verified in tests (e.g., EavMigrateJsonbToEavCommandTest asserts 1 migrated value in write flow), and unique index present on (entity_table, entity_id, attribute_id).
    - Schema/config changes:
      - Canonical eav_* schema; addTimestamps in generator; one eav_fk.

## Feature 3 — JSON
  - Scope
    - Postgres-only for this feature.
    - Engines uses attrs (jsonb), Parts uses spec (jsonb). For the plugin in general, the JSON column name must be configurable per table.
    - Keep JSON Attribute (eav_json.value) fully supported, but distinct from JSON Storage Mode. We’ll avoid conflating them.

  - Behavior: JSON Storage Mode
    - Enable via EavBehavior config on an application table: ['storage' => 'json_column', 'jsonColumn' => 'attrs'] or ['jsonColumn' => 'spec'].
    - Query rewriting: In beforeFind, detect conditions/order/selects that reference EAV attribute names and emit Postgres JSONB expressions:
      - string: (attrs->>'color') = 'red'
      - numeric: ((attrs->>'year_start')::int) >= 2010
      - boolean: ((attrs->>'is_active')::boolean) = true
      - dates/times: cast using appropriate types when we can resolve type (see “Type resolution”)

    - Projection as native fields: Inject expressions into SELECT so attributes appear as real entity properties (e.g., SELECT ((attrs->>'year_start')::int) AS year_start). Hydration type-corrected in afterFind via TypeFactory to guarantee PHP-native types for app use.
    - Magic finders: Cake’s magic finders work because conditions are rewritten (e.g., findByColor, findByYearStart).
    - Efficient writes: In [beforeSave]/write helpers (file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#saveEavValue), update single keys via jsonb_set instead of rewriting the entire JSON document. Support remove via attrs - 'key'. Parameterize and cast to jsonb correct types.
    - Indexing guidance:
    - GIN: CREATE INDEX ON engines USING GIN (attrs);
    - Functional: CREATE INDEX ON engines (((attrs->>'year_start')::int)); CREATE INDEX ON engines ((attrs->>'color'));
    - We’ll document these and optionally add helper generation later.

  - Type resolution strategy (to satisfy “typed primitives” without mandatory registry)
    - Priority order:
    - attributeTypeMap (behavior option): name => type. Quick, explicit, optional.
    - Attributes table registry: if present for name, use data_type (preferred for precision).
    - Automatic inference:
      - If the JSON value is numeric (actual JSON number), treat as integer/float depending on presence of decimal point/precision of comparison value.
      - If the JSON value is true/false, treat as boolean.
      - If a query condition is passed a Date/DateTime/Time object, cast accordingly in SQL (date, timestamp, time).
      - If the condition value is a scalar and matches unambiguous date/time patterns, we can cast cautiously (opt-in toggle to avoid over-eager inference).
      - Otherwise, default to string.
      - Caching: We’ll cache resolved types by attribute name per-table to avoid repeated lookups during a request.
      - Result: Numeric and boolean fields are reliably typed without a registry. Date/time achieve correctness if either the type map/registry exists or the query supplies typed values (e.g., where(['manufactured_at >=' => FrozenDate::today()])).

  - JSON Attribute vs JSON Storage Mode
    - JSON Attribute: data_type=json stored in eav_json.value. Existing behavior continues. jsonEncodeOnWrite applies here (and only here).
    - JSON Storage Mode: All attributes live in a single JSONB column (attrs/spec). No eav_json table needed. jsonEncodeOnWrite must be ignored here to prevent double-encoding; we will gate its use by storage mode.
    - Default: storage => 'tables'. Apps opt-in to JSON Storage Mode per entity table.

  - Setup Command and configuration
    - Today:
      - EavSetupCommand remains responsible for EAV tables (including eav_json.value json/jsonb). Keep --json-storage for JSON Attribute (we’ll document the naming to avoid confusion).
      - New in Feature 3 (lightweight addition, no schema changes to app tables automatically):
      - We’ll add support to declare JSON Storage Mode targets in the behavior config (per Table) and document how to add/ensure the JSONB column exists in your entity table (attrs/spec).
      - In a later feature, the command can optionally:
      - Prompt for JSON Storage Mode per app table and column name(s).
      - Generate migrations to add jsonb columns if missing (e.g., engines.attrs jsonb default '{}'::jsonb not null).
      - Column names for ProtechParts:
      - engines: attrs (jsonb)
      - parts: spec (jsonb)
      - We’ll use these in tests for this feature; behavior config will allow per-table override for other apps.
  - jsonEncodeOnWrite default
    - Set default to false globally.
    - Behavior will respect jsonEncodeOnWrite only in “tables storage” for JSON Attribute (eav_json). In JSON Storage Mode, it is ignored to prevent double-encoding. This preserves expectations and avoids regressions.

  - Do we require attributes to be created?
    - Not required in JSON Storage Mode. We support three resolution paths:
    - attributeTypeMap (explicit)
    - attributes registry (preferred for precision when available)
    - automatic inference for numbers/booleans; date/time when the condition value is typed or matches strict patterns.
    - Optional setting: autoRegisterUnknownAttributes (future): on save, automatically create missing attributes with inferred type for long-term consistency. Disabled by default; discuss later if desired.

  - Performance and storage: entity JSON column vs single “bundle table”
    - Option A: Entity table JSONB column (current approach; e.g., engines.attrs, parts.spec)
      - Pros:
        - No joins for attribute queries; simpler SQL and ORM integration.
        - Atomic updates via jsonb_set allow writing a single key without rewriting the entire document.
        - Functional indexes per “hot” attribute are straightforward:
          - Example: CREATE INDEX ON engines (((attrs->>'year_start')::int))
          - Example: CREATE INDEX ON engines ((attrs->>'color'))
        - GIN index on the column accelerates key existence/containment:
          - Example: CREATE INDEX ON engines USING GIN (attrs)
        - Operationally simple: one table to manage, fewer joins to tune.
      - Cons:
        - Every entity table carries the JSONB column even if sparse.
        - Duplicate index strategies may be needed per entity table if many tables use JSON Storage Mode.
        - Frequent attribute updates can increase write amplification and MVCC bloat on the main table (monitor VACUUM).
      - Postgres storage/size notes:
        - Prefer allowing NULL for sparse usage to avoid per-row “{}” overhead; coalesce in projections when needed.
        - Large JSONB values are TOASTed; if the column isn’t selected, Postgres won’t fetch the out-of-line value.
        - HOT updates are more likely to break if the JSONB column changes frequently; keep an eye on bloat and autovacuum settings.

    - Option B: Dedicated “bundle” table (plugin-managed), e.g., eav_bundle(entity_table, entity_id, data jsonb)
      - Pros:
        - Naturally sparse: only rows with attributes exist—no overhead in base tables.
        - Isolates churn: heavy attribute updates don’t bloat the main entity tables; reduces lock/contention on hot entities.
        - Centralized indexing: maintain one GIN index plus functional indexes scoped by entity_table.
        - Easier to archive or partition attribute data separately.
      - Cons:
        - Requires a join in every attribute query; more complex query rewriting and planning.
        - Still likely to maintain both a GIN index and multiple functional indexes (now on the bundle table).
        - Slightly more complex behavior logic and migrations.

    - Rule of thumb (Postgres):
      - If most rows have attributes and attribute reads/filters are common → use the entity JSONB column for simplicity and speed (zero joins).
      - If attributes are sparse or attributes change very frequently/are very large → use the dedicated bundle table to reduce base-table bloat and contention.
      - In either case, add:
        - GIN index on the JSONB document when you need containment/existence.
        - Targeted functional indexes for hot keys (cast to the correct type: int, boolean, date, etc.).

    - Recommendation for ProtechParts (current state):
      - Keep entity JSON column mode (attrs/spec) for Feature 3, as it’s already in use and avoids extra joins.
      - Allow NULL for the column (avoid default '{}'::jsonb) to reduce storage for sparse rows; COALESCE in projections if necessary.
      - Add a GIN index and targeted functional indexes (e.g., year_start, color) based on actual query patterns.
      - Reassess if update churn or table bloat becomes significant—then consider introducing a dedicated “json_side_table” backend.

    - Forward compatibility:
      - We can add a “json_side_table” storage backend later and make storage selectable per table via behavior config.
      - The behavior design will keep storage backends pluggable so switching is safe and requires minimal app changes.

  - Tests (specific to JSON Storage Mode)
    - Add fixtures for:
    - engines: id uuid, attrs jsonb
    - parts: id uuid, spec jsonb

  - Test cases:
    - Magic finders and conditions on string: findByColor, where(['color ILIKE' => 're%'])
    - Numeric compare: where(['year_start >=' => 2010]), orderDesc('year_start')
    - Boolean: where(['is_active' => true])
    - Date/time: pass typed values (FrozenDate/FrozenTime) and verify correct filtering and hydration
    - Hydration types: ensure entity->year_start is int, entity->is_active is bool, entity->manufactured_at is Date/DateTime as applicable
    - Save single attribute updates JSON via jsonb_set
    - Keep existing JSONB → EAV migrator tests (json_entities fixture) for the other direction.
  - Documentation updates (summary)
   - Clarify terminology: “JSON Attribute” (eav_json) vs “JSON Storage Mode” (entity JSON column).
   - How to enable JSON Storage Mode in behavior with per-table jsonColumn.
   - Index recommendations (GIN + functional).
   - Supported operators and typed casting rules, including how automatic typing works and where hints are needed (dates/times).
   - Setup command notes: --json-storage is for JSON Attribute; JSON Storage Mode configuration is behavior-based (for now). Future: interactive prompts to add JSONB columns to specified app tables.

  - Acceptance for Feature 3
   - With ['storage' => 'json_column', 'jsonColumn' => 'attrs'|'spec']:
   - Magic finders and standard where/order clauses over EAV attribute names work in Postgres with correct types.
   - Entities expose EAV attributes as native properties with PHP-native types.
   - Writes use jsonb_set to update single keys atomically.
   - JSON Attribute (eav_json) behavior and setup are unaffected.
   - jsonEncodeOnWrite default false globally; ignored in JSON Storage Mode; still respected for JSON Attribute.

### Summary: Feature 3 – JSON Storage Mode (EAV in a single JSON/JSONB column)

#### Overview
- Goal: Add a “JSON Storage Mode” to the EAV plugin so all attributes for an entity can be stored in a single JSON/JSONB column on the entity’s table (e.g., Items.attrs, Products.spec) while maintaining typed queries and CakeORM ergonomics.
  - Preserve existing “JSON Attribute” support (data_type=json in eav_json) and keep typed AV tables (eav_integer, eav_date, etc.) fully functional.

#### What was implemented

##### Behavior support
- Added JSON Storage Mode options and logic to the behavior:
    - `storage=json_column`, `jsonColumn=attrs|spec`
    - `attributeTypeMap` for typing hints per attribute
  - Projections and hydration
      - In `beforeFind`, the behavior:
          - Appends base table columns (so id and native columns remain available)
          - Projects JSON attributes as select aliases using Postgres JSONB extraction/casts
          - Registers the select type map for projected aliases so Cake hydrates as proper PHP-native types (date, float, int, bool)
  - Typed hydration
      - In `afterFind`, retained minimal deterministic casting as a safety net; primary typing is now via select type map (Cake-idiomatic)
  - Writes via jsonb_set
      - In `afterSave`, updates only changed keys using `jsonb_set`, via `Connection::updateQuery()` (CakePHP 5 API), with a proper `text[]` path cast. Null values remove keys.

##### Postgres JSONB helpers
- New trait encapsulating JSONB expressions, parameter binding, and typing resolution:
    - `plugins/Eav/src/Model/Behavior/JsonColumnStorageTrait.php`
  - Key capabilities:
      - SELECT/ORDER projections inline JSON key as safe SQL literals (avoid binding issues for keys) while identifiers are quoted via driver
      - WHERE fragments are parameterized and use `jsonb_exists((col)::jsonb, :key)` to avoid conflicts with the `?` operator and maintain PDO compliance
      - Batch `jsonb_set` updates with path cast to `text[]` and DB-level casting of values (e.g., `to_jsonb(:v::int)`)

##### Tests
- New generic plugin fixtures/tables for JSON Storage Mode:
    - `plugins/Eav/tests/Fixture/ItemsFixture.php` (items.attrs JSON)
    - `plugins/Eav/tests/Fixture/ProductsFixture.php` (products.spec JSON)
    - Existing domain-y fixtures (Engines/Parts) remain in repo but tests use generic Items/Products
  - JSON Storage Mode test case validates:
      - String/numeric/boolean queries via safe JSONB expressions
      - Ordering by projected alias (typed)
      - Null semantics (missing key)
      - Hydration types: date → `Cake\I18n\Date`; float/int/bool → native PHP types
      - `jsonb_set` partial updates on save
  - Cake 5 compatibility in tests:
      - Use `Cake\Database\Expression\QueryExpression` (not ORM namespace)
      - Use `orderByAsc`/`orderByDesc` (replacing deprecated `orderAsc`/`orderDesc`)

##### Migrations (tests)
- Plugin migration for test tables (if used in environment):
    - `plugins/Eav/config/Migrations/20251223000000_create_json_storage_test_tables.php`
  - Existing setup migrations for EAV tables remain:
      - `plugins/Eav/config/Migrations/20251221044219_eav_setup.php`
      - `plugins/Eav/config/Migrations/20251221093127_uuid_eav_setup.php`

#### Key decisions and compliance notes
- PDO compliance:
    - WHERE and UPDATE values are bound as named parameters
    - Avoid Postgres `?` key-existence operator; use `jsonb_exists`
    - For SELECT/ORDER projections, JSON key (attribute name) is embedded as a safely quoted SQL literal; all values remain parameterized
  - CakePHP 5.x API usage:
      - Driver-based identifier quoting (`getDriver()->quoteIdentifier`)
      - `updateQuery()` for updates; `UpdateQuery::newExpr()` for raw expressions
      - Select type map for typed hydration
      - No `Connection::quote`/`quoteIdentifier`; removed `TableRegistry` usage in new code paths; use `getTableLocator()`
  - JSON Attribute vs JSON Storage Mode:
      - JSON Attribute (eav_json) continues to work unchanged
      - JSON Storage Mode is per-table via behavior config; no app schema changes are performed automatically by this feature

#### Not included (future features)
- SetupCommand changes for JSON Storage Mode (interactive prompts/migrations for app columns/indexes) — planned future enhancement
  - Automatic condition rewriting for attribute names in plain ORM where/magic finders — to be added in a follow-up feature (tests currently use explicit JSONB expressions)

#### Files created
- Behavior helper:
    - `plugins/Eav/src/Model/Behavior/JsonColumnStorageTrait.php`
  - Test fixtures (generic):
      - `plugins/Eav/tests/Fixture/ItemsFixture.php`
      - `plugins/Eav/tests/Fixture/ProductsFixture.php`
  - Test migration (optional in your environment):
      - `plugins/Eav/config/Migrations/20251223000000_create_json_storage_test_tables.php`
  - Test case:
      - `plugins/Eav/tests/TestCase/Model/Behavior/EavJsonStorageModeTest.php`

#### Files modified
- Behavior core:
    - `plugins/Eav/src/Model/Behavior/EavBehavior.php`
  - Fixtures/tests (updated or referenced):
      - `plugins/Eav/tests/Fixture/EavStringFixture.php`
      - `plugins/Eav/tests/Fixture/EavJsonFixture.php`
      - `plugins/Eav/tests/TestCase/Model/Behavior/EavBehaviorTest.php`
      - `plugins/Eav/tests/TestCase/Command/EavSetupCommandTest.php`
  - Migrations (existing EAV setups retained/used as-is):
      - `plugins/Eav/config/Migrations/20251221044219_eav_setup.php`
      - `plugins/Eav/config/Migrations/20251221093127_uuid_eav_setup.php`

#### Runbook
- Apply plugin migrations on test connection (if using test migration):
    - `bin/cake migrations migrate -p Eav -c test`
  - Run plugin tests:
      - `vendor/bin/phpunit plugins/Eav/tests`

#### Acceptance/Outcomes
- JSON Storage Mode is available and tested on Postgres:
    - Entities expose JSON attributes as native fields with correct PHP types
    - Queries and ordering supported via Postgres JSONB expressions with proper DB casts
    - Saves update only changed keys via `jsonb_set` with `text[]` path
  - Existing JSON Attribute and typed AV table paths remain intact

#### Follow-ups recommended
- Implement automatic condition rewriting in EavBehavior (beforeFind) for magic finders and plain `where(['attr >' => 10])` without raw expressions
  - SetupCommand enhancements for JSON Storage Mode:
      - Interactive prompts per table/column
      - Optional migrations to add JSONB columns and indexes (GIN + functional)
  - Documentation refresh in README for JSON Storage Mode and indexing recommendations

## Feature 4 — Setup Command (Interactive)

Goals
- Provide an interactive setup wizard with driver-aware defaults and minimal required flags (flags remain for CI).
- Support both output modes:
  - Migrations (default, cross-DB)
  - Raw SQL (initially Postgres and MySQL; SQL Server/SQLite will fall back to Migrations with a notice)
- Persist selections to plugins/Eav/config/eav.json for future reference and behavior defaults.
- Optionally help configure JSON Storage Mode per entity table (Postgres/MySQL), without forcing it globally.

Approach
- Wrapper command (Approach B): add a new interactive command and keep the existing generator stable.
  - New command: eav setup:interactive (wrapper/wizard)
  - Existing command: [EavSetupCommand](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php) remains non-interactive and focused on deterministic file generation.
  - Magic entry: running “bin/cake eav setup” without key flags launches the wizard (unless --no-interactive is provided). With flags present, it behaves non-interactively as today.

Prompt flow (wizard)
1) Connection
   - List configured connections (via ConnectionManager); show driver per connection; default to “default” if present.
2) Output mode
   - migrations (default)
   - raw_sql (Postgres/MySQL supported now; others fall back to migrations with a notice)
3) PK family
   - uuid or int
   - If uuid: choose subtype with driver-based recommendation:
     - Postgres: nativeuuid (Recommended)
     - MySQL/MariaDB: binaryuuid (Recommended)
     - SQL Server: nativeuuid (Recommended)
     - SQLite: uuid (string) (Recommended)
4) JSON Attribute column type (for eav_json.value)
   - json or jsonb (jsonb only if driver is Postgres; otherwise auto-fallback to json with a notice)
5) Behavior storage default
   - tables (typed AV tables; default)
   - json_column (JSON Storage Mode per table; Postgres/MySQL only in this feature)
6) JSON Storage Mode (per-table, optional)
   - If json_column chosen above:
     - Enumerate app tables (like Bake) and allow selecting one or more entity tables.
     - For each selected table:
       - Pick an existing JSON/JSONB column, or
       - Generate a migration to add one:
         - Postgres: jsonb NULL (no default '{}'); optional indexes:
           - GIN on the JSONB column
           - Functional indexes (typed extracts) for “hot” keys (optional; list keys as CSV)
         - MySQL: json NULL; index generation deferred (document limitations)
     - Persist mapping in eav.json: {"items":"attrs", "products":"spec"}.
7) jsonEncodeOnWrite default
   - yes/no (default: no) — applies only to JSON Attribute (eav_json) in tables storage; ignored in JSON Storage Mode.
8) Types to scaffold
   - defaults, all, or CSV of extras (aliases normalized; validated against TypeFactory/custom ‘fk’).
9) Migration name
   - Default: EavSetup; allow custom suffix for clarity.
10) Confirm and generate
   - Print a summary of all answers; proceed on confirmation.

Outputs
- Always persist to plugins/Eav/config/eav.json with:
  - connection, driver, outputMode, pkType, uuidType
  - jsonAttributeStorage (json|jsonb)
  - jsonEncodeOnWrite default
  - storageDefault (tables|json_column)
  - jsonColumns mapping (per-table json column names, if provided)
  - types list
  - migrationName
  - generatedAt (ISO 8601)
- If output is Migrations:
  - Delegate to [EavSetupCommand](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php) to build migration payload.
  - Add a header docblock summarizing all selections to the migration file.
  - Print the exact migrate command with the chosen connection: “bin/cake migrations migrate -p Eav -c <connection>”.
- If output is Raw SQL:
  - Postgres/MySQL: generate DDL with the same canonical schema:
    - attributes, attribute_sets, attribute_set_attributes
    - eav_* tables with id, entity_table, entity_id, attribute_id, value (nullable), timestamps
    - Unique index: (entity_table, entity_id, attribute_id) and FK on attribute_id
    - eav_json.value type per selection (json|jsonb)
  - Write SQL to a file (e.g., plugins/Eav/config/Sql/<timestamp>_<name>.sql) or stream to console if write fails.
  - SQL Server/SQLite: show “coming soon” and fall back to Migrations.

Schema specifics for all eav_* tables (unchanged)
- id: UUID (row id via chosen uuidType)
- entity_table: string(191)
- entity_id: uuidType or biginteger based on PK family
- attribute_id: UUID
- value: per eav_<type> (json/jsonb for eav_json), NULL allowed
- created, modified: via addTimestamps (migrations) or DB defaults (SQL)
- Unique index: (entity_table, entity_id, attribute_id)
- FK: attribute_id -> attributes.id (ON DELETE CASCADE)

Non-interactive and CI behavior
- Keep current flags for [EavSetupCommand](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php) intact (pk-type, uuid-type, json-storage, types, name, connection, dry-run).
- eav setup with any key flags remains non-interactive; with no flags, show a one-line hint and launch the wizard unless --no-interactive is set.

Acceptance
- Running “bin/cake eav setup” with no key flags launches the interactive wizard; with flags or --no-interactive, it remains non-interactive.
- eav.json is written at plugins/Eav/config/eav.json with all selected options, including per-table jsonColumns mapping when provided.
- Migrations output path uses canonical eav_* naming, unified entity_id, nullable value, addTimestamps, and prints the exact migrate command with the chosen connection.
- Raw SQL output:
  - Postgres/MySQL: SQL file generated successfully; SQL Server/SQLite fall back to Migrations with a notice.
- JSON Storage Mode prompts:
  - App tables listed; user can pick per-table JSON column (existing or create via migration).
  - For Postgres, optional GIN and functional indexes can be included.
- Backward compatibility: existing non-interactive usage (flags) continues to work unchanged.

Tests (to add with implementation)
- ConsoleIntegrationTestTrait coverage for:
  - Non-interactive path (flags) remains identical to current behavior.
  - Interactive flow happy path simulated via mocked IO (prompt/answer sequences).
  - eav.json content structure/assertions (decode and validate keys).
  - Postgres raw SQL generation sanity (header, tables, indexes present).
  - MySQL raw SQL generation sanity (header, tables present).
  - SQL Server/SQLite paths show fallback notice and write a migration.

### Feature 4 — Interactive Setup Command (Completed Summary)

Overview
- Implemented an interactive setup wizard that guides configuration and generates schema via migrations or raw SQL.
- Preserved non-interactive usage for CI and scripts, with “magic” interactive launch when no flags are provided (except during --dry-run).
- Persisted selections to plugins/Eav/config/eav.json and added header stamps to generated files.

Highlights
- New interactive command: eav setup:interactive
- Auto-launch wizard from eav setup when no key flags are provided (unless --no-interactive or --dry-run).
- Non-interactive flags extended with:
    - --config: load options from eav.json
    - --output: migrations|raw_sql (raw_sql supported for Postgres/MySQL; others fall back to migrations)
- Raw SQL output generation for Postgres/MySQL, including header metadata
- JSON Storage Mode (json_column) support in the wizard:
    - Per-table mapping and optional migration/SQL to add JSON/JSONB columns (GIN/functional indexes optional on Postgres)
- jsonEncodeOnWrite prompt added; default false globally

Interactive Wizard Flow
1) Choose connection (lists configured connections; default to “default” when available).
2) Choose output mode: migrations (default) or raw_sql (Postgres/MySQL supported; SQL Server/SQLite fall back to migrations with a notice).
3) PK family: uuid or int; if uuid, choose subtype with driver-aware recommendation:
    - Postgres/SQL Server: nativeuuid (recommended)
    - MySQL/MariaDB: binaryuuid (recommended)
    - SQLite: uuid (string) (recommended)
4) JSON Attribute storage for eav_json.value: json or jsonb (jsonb only when Postgres; otherwise falls back to json).
5) Default behavior storage: tables or json_column.
6) JSON Storage Mode per-table (when json_column selected):
    - Enumerate app tables; allow multi-select by number.
    - For each table: choose an existing JSON column or type a new column name (normalized).
    - Optionally generate a migration or raw SQL to add the column; Postgres supports optional GIN and functional indexes.
7) jsonEncodeOnWrite for JSON Attribute writes (applies to tables mode only).
8) Types to scaffold: defaults, all, or CSV with alias normalization and TypeFactory validation.
9) Migration/SQL base name (default EavSetup).
10) Summary confirmation and generation.

Persistence (eav.json)
- plugins/Eav/config/eav.json stores:
    - connection, driver
    - outputMode (migrations|raw_sql)
    - pkType, uuidType
    - jsonAttributeStorage (json|jsonb)
    - jsonEncodeOnWrite (boolean)
    - storageDefault (tables|json_column)
    - jsonColumns mapping: { "table": "jsonColumn" }
    - types (normalized)
    - migrationName
    - generatedAt (ISO8601)
    - For raw_sql runs: rawSql { driver, file }

Output Modes
- Migrations (default):
    - Delegates to EavSetupCommand to generate a Cake Migration with canonical eav_* tables:
        - attributes, attribute_sets, attribute_set_attributes
        - eav_* typed tables with: id, entity_table, entity_id, attribute_id, value (nullable), created, modified
        - Unique index (entity_table, entity_id, attribute_id), FK attribute_id -> attributes(id) ON DELETE CASCADE
    - Header summary injected (connection, driver, pk/uuid/json options, types, generatedAt)
- Raw SQL (Postgres/MySQL):
    - Generates canonical DDL with header summary
    - SQL Server/SQLite: fall back to migrations with notice
    - Wizard also appends JSON Storage column/index DDL (where applicable) to the SQL snapshot

Non-Interactive Enhancements
- --config to load eav.json options for deterministic runs
- --output migrations|raw_sql (honored for Postgres/MySQL)
- Magic interactive launch is skipped during --dry-run to keep test/CI non-interactive

Backward Compatibility
- Flag-based usage preserved; interactive “magic” only when no key flags and not a dry run
- Postgres-only behavior for jsonb and ILIKE is guarded
- Migrations remain the default path for portability

Acceptance (met)
- bin/cake eav setup launches the wizard when no flags (unless --no-interactive or --dry-run). Explicit wizard: bin/cake eav setup:interactive.
- eav.json is written with all choices (including jsonColumns, jsonEncodeOnWrite).
- Migrations are generated with header stamps and canonical schema; raw SQL snapshot is generated for Postgres/MySQL and recorded in eav.json.
- JSON Storage Mode per-table mapping supported; optional migration/SQL generated to add JSON columns and optional Postgres indexes.

Files Changed
- New
    - plugins/Eav/src/Command/EavSetupInteractiveCommand.php
- Modified
    - plugins/Eav/src/Command/EavSetupCommand.php
        - Added --interactive/--no-interactive and magic launch (skipped during --dry-run)
        - Added --config and --output (migrations|raw_sql)
        - Implemented raw SQL generator for Postgres/MySQL
        - Header stamping for migrations and raw SQL
    - plugins/Eav/src/EavPlugin.php
        - Registered eav setup:interactive command
    - plugins/Eav/src/Model/Behavior/EavBehavior.php
        - Default jsonEncodeOnWrite flipped to false (aligned with feature decisions)
- Tests Created/Updated
    - plugins/Eav/tests/TestCase/Command/EavSetupCommandTest.php (expanded)
        - testMigrationDryRunOutputsMigration
        - testRawSqlDryRunOnSupportedDrivers
        - testConfigFileRespectedForOutputModeAndTypes
    - plugins/Eav/tests/TestCase/Model/Behavior/EavBehaviorTest.php (updated)
        - Aligned JSON expectation with jsonEncodeOnWrite=false default

Runbook
- Interactive wizard:
    - bin/cake eav setup
    - bin/cake eav setup:interactive
- Non-interactive (migrations):
    - bin/cake eav setup --connection default --pk-type uuid --uuid-type nativeuuid --json-storage json --types defaults
- Non-interactive (raw SQL):
    - bin/cake eav setup --connection default --output raw_sql --pk-type uuid --uuid-type nativeuuid --json-storage json --types defaults
- Apply migrations:
    - bin/cake migrations migrate -p Eav -c <connection>

Future Work
- Refactor to a SetupWizard service to share logic between commands (agreed roadmap).
- Add interactive command tests (planned in Feature 8).
- Documentation updates (README/PLAN) with screenshots and usage examples.

## Feature 5 — EavEntities / EavAttributes / EavAttributeSets
Goals
- Prefix model classes and tables to avoid collisions and keep grouping.
  - Tables: eav_entities, eav_attributes, eav_attribute_sets, eav_attribute_set_attributes
  - Classes: EavEntitiesTable, EavAttributesTable, EavAttributeSetsTable, EavAttributeSetAttributesTable
- Associations:
  - EavAttributes belongsToMany EavAttributeSets through EavAttributeSetAttributes.
  - EavAttributeSets belongsToMany EavAttributes through EavAttributeSetAttributes.
  - EavEntities is a registry of app entities; explicit hasMany to typed values is not modeled (values live in multiple typed tables). The Behavior provides the entity-aware access to values.
- Validation: names required/unique, label lengths, Timestamp behavior across all.

Acceptance
- Bake CRUD for EavAttributes, EavAttributeSets, EavAttributeSetAttributes, and EavEntities.

## Feature 6 — Command connection handling
- Auto-detect default datasource; prompt if multiple.
- Keep optional flags for CI but not required for interactive use.
- Maintain Postgres guard for JSONB in [EavMigrateJsonbToEavCommand#execute](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavMigrateJsonbToEavCommand.php#execute).

## Feature 7 — Behavior consistency and finder

Goals
- Make EAV attributes behave like native fields in queries across both storage modes:
  - Support Cake magic finders (e.g., findByColor, findByYearStart).
  - Rewrite attribute conditions, ordering, and projections automatically and safely.
  - Guarantee typed hydration via Cake’s SelectTypeMap and TypeFactory.
- Keep the system DB-agnostic where possible; use Postgres-specific JSONB features only in JSON Storage Mode or when using a JSON Attribute.

Scope
- Applies to both storage modes:
  - Typed EAV tables (“tables” storage; default).
  - JSON Storage Mode (“json_column”; Postgres-only per Feature 3).
- Includes condition rewriting, ordering, projections, and typed hydration.
- Backward compatible:
  - Existing [findByAttribute](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#findByAttribute) remains available.
  - Existing JSON Attribute (eav_json.value) path unchanged.

Implementation details
- Canonical resolution (already in place; reaffirmed here)
  - [EavBehavior#tableTypeSegment](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#tableTypeSegment)
  - [EavBehavior#avTableClass](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#avTableClass)
  - [EavBehavior#tableFor](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#tableFor)
  - Unified [EavBehavior#entityIdField](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#entityIdField) = entity_id.

- Automatic condition rewriting (beforeFind)
  - Parse where() conditions and magic finder conditions that reference attribute names (e.g., ['color' => 'red'], ['year_start >=' => 2010], ['name ILIKE' => '%a%']).
  - Route per storage mode:
    - Tables storage: generate a single innerJoin per attribute/type onto the corresponding eav_<type> table with (entity_table, entity_id, attribute_id) constraints. Reuse joins when multiple conditions target the same attribute/type.
    - JSON Storage Mode: emit Postgres JSONB expressions via helpers in [JsonColumnStorageTrait](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/JsonColumnStorageTrait.php) (->>, casts, jsonb_exists).
  - Supported operators: =, !=, >, >=, <, <=, IN, NOT IN, LIKE, ILIKE (Postgres), IS NULL, IS NOT NULL.
  - Type resolution (reused from Feature 3): attributeTypeMap > Attributes registry > inference (numbers/booleans; cautious date/time) to drive SQL casts and hydration.

- Projection and ordering
  - Project requested attributes as aliased select fields using safe SQL fragments and add select type map entries so Cake hydrates to PHP-native types.
  - Apply ORDER BY via typed expressions (casted extract for JSON Storage; joined value column for tables storage).

- Safety and portability
  - Always use ORM expression builders and named parameters; avoid raw concatenation and the Postgres “?” operator. Use jsonb_exists for key existence checks.
  - Provide a per-query opt-out flag (e.g., options(['eavRewrite' => false])) for advanced callers.
  - Ensure no N+1 joins: batch join strategy for multiple attributes; reuse join aliases when possible.

- Backward compatibility
  - [findByAttribute](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#findByAttribute) remains supported and internally leverages the same type resolution and storage-mode routing.
  - Existing explicit maps in behavior config (map) continue to work and can drive which attributes are projected by default.

Tests
- Tables storage (typed EAV):
  - Query rewriting: equality, range comparisons, IN/NOT IN, LIKE; IS NULL/NOT NULL.
  - Ordering by attribute fields (asc/desc).
  - Typed hydration for integer, float/decimal (string for decimal), boolean, date, datetime, time, uuid.
  - Multiple attribute conditions ensure single join per attribute/type (no duplicate joins).
- JSON Storage Mode (Postgres):
  - Same operator coverage using JSONB expressions (->>, casts).
  - Ordering by attribute fields via casted expressions.
  - Typed hydration via SelectTypeMap.
  - Null/missing key semantics via jsonb_exists.
- Magic finders:
  - findBy<Color/YearStart/...> works equivalently in both modes.
- Opt-out:
  - When eavRewrite=false, conditions are not rewritten; user-provided raw conditions apply.

Acceptance
- For both storage modes, the following pass using only native Cake ORM syntax (no raw SQL in app code):
  - Attribute-based filtering with supported operators produces correct SQL and results.
  - Attribute-based ORDER BY works and respects type casting.
  - Returned entities have PHP-native types for projected attributes (per TypeFactory expectations).
- No duplicate joins for multiple conditions on the same attribute/type in tables storage.
- JSON Storage Mode uses parameterized JSONB expressions (no “?” operator), and null semantics are correct via jsonb_exists.
- A per-query opt-out exists and is honored.
- Existing JSON Attribute and typed EAV paths remain functional and unchanged in behavior.

  - Summary of Feature 7 (Query Rewriting + Projections for EAV)
 - What was delivered
   - Unified query rewriting in the behavior:
   - JSON Storage Mode (entity-level JSON/JSONB column)
    - Automatic projections so attributes behave like native fields in SELECT/ORDER.
    - Implemented in beforeFind using buildSelectProjection and applyProjection.
     - Attribute-based WHERE rewriting for:
     - Flat array conditions in options: buildWhereFragment + applyWhere
     - expression-tree conditions added via ->where([...]) and grouped logic: rewriteJsonWhereTree
     - Typed ORDER BY with default NULLS LAST: buildOrderFragment + applyOrder
     - Correct WHERE null semantics for absent keys via jsonb_exists
   - Tables Storage Mode (eav_* AV tables)
     - One join per attribute/type with deduplication; WHERE rewrite supports =, !=, >, >=, <, <=, IN/NOT IN, LIKE/ILIKE, IS NULL/IS NOT NULL:
     - Array conditions path in beforeFind
     - Expression-tree rewrite in rewriteTablesWhereTree
     - Projections to expose attribute values as select aliases for ORDER/hydration
     - ORDER BY on attributes with NULLS LAST (native on Postgres, emulation on others) within beforeFind
   - Per-query controls and safety:
     - eavRewrite option (default true) to disable rewriting per query at beforeFind
     - eavTypes option to hint types per query (drives JSON casts and AV table selection)
     - Collision guard so native columns are never treated as attributes (base schema introspected in beforeFind)
   - JSON writes and typed hydration retained:
   - JSON writes via jsonb_set in afterSave using buildJsonbSetUpdateSql
   - Typed post-hydration for JSON projections in afterFind
   - Setup generator and migrations:
   - Generated AV tables now have nullable value columns (aligns with “explicit NULL” rows + missing-row semantics) in the generated migrations (see config/Migrations), produced by EavSetupCommand#buildMigration
   - Setup command now always prints the connection-specific migrate command in execute
   - Migration/utility command hardening:
   - EavMigrateJsonbToEavCommand#execute uses jsonb_exists and supports --connection with dry-run/batching

 - Tests that validate the feature
   - JSON Storage Mode tests: EavJsonStorageModeTest
     - String/numeric/boolean/date queries with typed projections and ordering
     - Where rewriting with plain attribute names (no raw JSONB), including IN and IS NULL semantics
     - Explicit select(['id','color']) projection and ORDER by attribute alias
   - Tables Storage Mode tests: EavTablesStorageModeTest
     - Equality where rewrite (color = 'red'), IS NULL semantics (missing row treated as NULL), ORDER BY with NULLS LAST
     - Test fixture TestEntitiesFixture and AV fixtures validate join + projection behavior
   - Behavior infrastructure tests: EavBehaviorTest
     - Type normalization, casting, batched fetch, and creating attributes on save
   - Command tests:
     - EavSetupCommandTest dry-run output
     - EavCreateAttributeCommandTest create/no-op duplicate flow

 - Acceptance criteria vs goals
   - AC: “EAV attributes act like native fields in queries” (where/order/select) across both storage modes
   - Met. JSON: alias projections + typed WHERE/ORDER rewrite. Tables: joins + projections + ORDER rewrite.
   - AC: “Per-query opt-out and typing overrides”
   - Met via options(['-eavRewrite' => false]) and options(['eavTypes' => ['attr' => 'type']]) in beforeFind
   - AC: “Null semantics consistent”
   - Met. JSON uses jsonb_exists for missing-key-as-NULL; Tables uses LEFT JOIN + value IS NULL; AV “value” columns are nullable.
   - AC: “Ordering NULLS LAST by default”
   - Met. JSON adds NULLS LAST in buildOrderFragment; Tables enforces at beforeFind (native on Postgres; emulated elsewhere).
   - AC: “No native column collisions”
   - Met. Collision guard prevents attribute rewriting for base table columns.
   - AC: “Generator and commands support production workflows”
   - Met. Setup command generates nullable AV value columns and prints connection-aware migrate command; migration utility hardened for Postgres JSONB.

 - Notable implementation details
   - Type resolution precedence: behavior map/attributeTypeMap > eavTypes (per-query) > Attributes registry > inference > default 'string'
   - Safe parameter binding everywhere (no string concatenation of values)
   - Deduplicated joins per attribute/type alias in tables storage
   - Centralized select type normalization via normalizeSelectType

 - Outcome
   - All plugin tests pass locally against Postgres with PHP 8.1, validating JSON and tables storage modes, command behavior, and setup generation.
   - Feature 7’s goals are achieved; the behavior now makes EAV attributes first-class citizens in ORM query building with sensible defaults and escape hatches.

## Feature 8 — Tests
- Rename fixtures from av_* to eav_*; switch ‘val’ to ‘value’; ensure unified entity_id across fixtures.
- Update tests that assumed AvJsonbUuid class naming (canonicalize to EavJson).
- Add tests for interactive Setup (simulated answers), UUID subtype recommendations, and type selection.
- Add CRUD tests for EavAttributes/EavAttributeSets/EavEntities.
- Add regression coverage for jsonEncodeOnWrite true/false.

## Feature 9 — UI scaffolding (bake)
- Bake CRUD for:
  - EavAttributes
  - EavAttributeSets
  - EavAttributeSetAttributes
  - EavEntities
- Basic forms for adding attributes and organizing sets per entity.
- Controller/View route naming can follow plugin defaults; no additional “Eav” prefix in URLs is required beyond the plugin name (Eav).

## Feature 10 — Documentation
- Rewrite README with:
  - Overview and capabilities (no 2.x migration notes).
  - Setup walkthrough (interactive prompts) with examples.
  - Supported types: default vs optional; geospatial caveats.
  - UUID subtype recommendations by driver.
  - jsonEncodeOnWrite and hydration expectations.
  - Behavior attachment and mapping examples.
  - AttributeSets and EavEntities usage.
  - Raw SQL vs Migrations options.
- Maintain a CHANGELOG for notable plan/architecture changes.

Storage modes and when to choose which
- Typed EAV tables (“tables” storage, default):
    - Best when attributes are shared across many entities, you need per-attribute constraints/joins, or DB portability matters.
    - Sparse storage by nature (no empty columns); joins add complexity, but behavior makes fields feel native.
- JSON Storage (entity JSON column, Postgres-only in Feature 3):
    - Best when most rows have attributes and you want zero joins with transparent ORM integration.
    - Use functional indexes per “hot” attribute and a GIN index on the JSONB column.
    - Allow NULL for sparse tables to avoid per-row “{}” overhead; coalesce in projections as needed.
- Clear terminology in Setup:
    - “JSON Attribute column type” is the json/jsonb choice for eav_json.value.
    - “Storage mode” determines whether attributes live in typed EAV tables (default) or in an entity JSONB column (JSON Storage Mode).
    -
Deprecations and removals
- Remove config/Migrations/*.sql legacy snapshots (regenerate via Setup).
- Remove Av* classes and av_* fixtures as we migrate; no TableLocator alias needed. Replace all usage with Eav* and eav_*.

Risks and mitigations
- Naming/schema migration: handled via Setup regeneration and clear upgrade notes.
- JSONB availability: guard on Postgres; fall back to JSON elsewhere with a notice.
- Advanced types by driver: warn/skip when unsupported; allow opt-in explicitly.
- Interactive setup in CI: flags remain available for non-interactive runs.

Immediate actionable checklist
- Behavior:
  - Canonicalize to Eav* classes and eav_* tables.
  - Unify entity_id naming and column usage (remove entity_int_id).
  - Rename val -> value across behavior, commands, and tests.
  - Add jsonEncodeOnWrite config and gate JSON encoding.
- Setup:
  - Convert to interactive prompts; add connection detection and driver-based defaults.
  - Generate Migrations or raw SQL; eav_* names; entity_id; value column; timestamp defaults.
  - Persist chosen config to plugins/Eav/config/eav.json; stamp migration/SQL comments.
  - Allow type selection (defaults + optional).
- Commands:
  - Keep Postgres guard in JSONB migrator.
  - Use detected default connection; prompt if multiple; allow flag for CI.
- ORM:
  - Add EavEntities, EavAttributes, EavAttributeSets, EavAttributeSetAttributes with associations and validation.
  - Generate Eav* value tables for selected types, or provide a generator step.
- Tests:
  - Update fixtures, test names, and expectations to eav_* and value.
  - Add interactive setup tests; CRUD tests; jsonEncodeOnWrite tests.
- Docs:
  - Rewrite README; add CHANGELOG entry; cross-link to this PLAN.

Process & governance
- This PLAN.md is the source of truth. Update via PR in branches tied to JIRA tickets (1 feature per branch).
- AGENTS.md should link to this file and summarize status; AGENTS-VSCode.md remains deprecated.
- Per-feature conversation template (include in each chat):
  - Link to this plan: plugins/Eav/PLAN.md
  - JIRA issue key and scope
  - Target files to modify (paths)
  - Desired acceptance criteria and tests to add/update
  - Any special driver assumptions
- After each feature completes, add a short “Conversation Summary” back into this PLAN (or docs/features/FEATURE-<key>.md) with:
  - What changed (files, schema)
  - Commands run
  - Table counts or verifications
  - Follow-ups/TODOs

Driver-based UUID recommendations (used in Setup)
- Postgres: nativeuuid (Recommended)
- MySQL/MariaDB: binaryuuid (Recommended)
- SQL Server: nativeuuid (Recommended)
- SQLite: uuid (string) (Recommended)

## Feature 11 — Interactive Setup Command Service (Convert Feature 4 to a Service)

Architecture (Exploratory; multiple competing approaches)

Objective
- Extract all setup logic (prompting, defaults, validation, generation, persistence) from the console commands into a reusable, testable service layer.
- Keep commands thin; both non-interactive and interactive commands delegate to the service.
- Maintain backward compatibility with existing CLI flags and eav.json while improving testability and cohesion.

Scope
- Create a service layer under namespace Eav\Setup that:
  - Owns DTO(s) for configuration and generation inputs/outputs (e.g., SetupConfig).
  - Encapsulates driver-aware defaults, type selection and normalization, config persistence (plugins/Eav/config/eav.json), header-stamp composition, and output writing (migrations and raw SQL).
  - Exposes a single orchestration entrypoint called by both commands.
- Non-goals for Feature 11:
  - Adding new DB vendors or features beyond Feature 4. This is a refactor to centralize logic.

Existing entry points to refactor
- Interactive wizard: [EavSetupInteractiveCommand#runInteractive](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupInteractiveCommand.php#runInteractive)
- Non-interactive path and raw SQL generation: [EavSetupCommand#execute](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#execute)
- Helpers to eventually migrate into the service:
  - Type resolution: [resolveSelectedTypes](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#resolveSelectedTypes)
  - Migration builder: [buildMigration](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#buildMigration)
  - SQL generator: [buildRawSql](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#buildRawSql)
  - File output helpers: [migrationPath](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#migrationPath), [nextMigrationFilename](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#nextMigrationFilename), [sqlOutputPath](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#sqlOutputPath), [nextSqlFilename](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#nextSqlFilename)

Approach A — Keep logic in commands; add a lightweight utility class
- Structure:
  - Extract only config read/write and header stamping to a small helper; keep buildMigration/buildRawSql in commands.
  - Interactive command remains responsible for prompting.
- Pros:
  - Minimal refactor; lower risk.
- Cons:
  - Does not solve cohesion or testability: core generation remains in commands.
  - Duplicate logic risks persist.

Approach B — Single “Wizard” wrapper that invokes existing commands internally
- Structure:
  - A Wizard facade that composes CLI argument lists and internally dispatches the existing commands via a runner.
- Pros:
  - Minimal code churn; reuses existing stable command flows.
- Cons:
  - Commands remain the source of truth; poor unit-test targeting.
  - Harder to validate internal states without CLI indirection.

Approach C — Dedicated service layer (recommended)
- Structure:
  - New service namespace Eav\Setup with components:
    - SetupConfig (immutable DTO): user selections and derived values.
    - SetupDefaults: driver-aware defaults (PK family, UUID subtype, JSON storage).
    - TypeResolver: alias normalization and validation against TypeFactory + custom types.
    - DriverCapabilities: DB vendor capabilities (jsonb, uuid type, etc.).
    - ConfigRepository: read/write eav.json with schema validation.
    - HeaderBuilder: builds migration/SQL header summary.
    - MigrationBuilder: produces migration payload (moves code from command builder).
    - SqlGenerator: DDL for Postgres/MySQL (moves code from command builder).
    - OutputWriter: writes migration or SQL files (uniform path and naming).
    - WizardPrompter: wraps ConsoleIo for prompts (interactive only).
  - Commands:
    - [EavSetupInteractiveCommand](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupInteractiveCommand.php): prompts via WizardPrompter, builds SetupConfig, calls service orchestrator.
    - [EavSetupCommand](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php): parses flags/--config, builds SetupConfig, calls service orchestrator; retains magic launch (but prompting lives in service prompter).
- Pros:
  - High cohesion, unit-testable components.
  - Single source of truth for generation across modes (migrations/raw SQL).
  - Clean path to extend (SQL Server/SQLite) without altering commands.
- Cons:
  - Largest initial refactor; risk of regressions if not covered by tests.
  - Requires careful BC shims for existing public helpers on commands.

Cross-cutting concerns and trade-offs
- IO Abstraction: Prompter must be injectable/mocked for tests. Commands pass ConsoleIo, service uses WizardPrompter interface.
- Backward Compatibility: Keep CLI options/behavior identical; commands remain entrypoints; public helpers in commands proxy to service and get marked deprecated.
- Config precedence: CLI flags > eav.json values > driver defaults. Service must apply merging deterministically.
- Error handling: Service components throw precise exceptions; commands translate to exit codes and friendly messages.
- File system: WSL path/write errors; service returns write results and messages; commands print guidance on failure.
- Risks and mitigations:
  - Risk: Dual code paths drifting. Mitigation: single orchestration service; commands call service only.
  - Risk: Tests flapping due to driver differences. Mitigation: driver capability adapter + golden outputs in tests.
  - Risk: Timing-based filenames in tests. Mitigation: allow injecting a Clock or prefix stub for deterministic filenames during tests (optional).

Recommendation
- Adopt Approach C (service layer). Keep commands as thin adapters and retain flags/UX. Introduce service components with unit tests.

Planning (Converged; step-by-step)

Decision
- Implement Approach C. Retain current commands for UX/BC, but delegate logic to the service.

Deliverables
- New namespace/classes under plugins/Eav/src/Setup:
  - SetupConfig (DTO)
  - SetupDefaults
  - TypeResolver
  - DriverCapabilities
  - ConfigRepository
  - HeaderBuilder
  - MigrationBuilder
  - SqlGenerator
  - OutputWriter (MigrationWriter, SqlWriter combined)
  - WizardPrompter (interactive only; wraps ConsoleIo)
  - SetupOrchestrator (facade): build config, validate, generate payload, write outputs, update eav.json rawSql pointer
- Command refactors:
  - [EavSetupInteractiveCommand](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupInteractiveCommand.php): replace ad-hoc logic with WizardPrompter + Orchestrator.
  - [EavSetupCommand](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php): parse flags/--config, build SetupConfig, call Orchestrator; keep magic launch, but wizard lives in service.

Implementation plan
1) Introduce the core DTO and helpers
   - SetupConfig: immutable config; includes connection, driver FQCN, outputMode, pkType, uuidType, jsonAttributeStorage, jsonEncodeOnWrite, storageDefault, jsonColumns map, types, migrationName, generatedAt.
   - SetupDefaults: derive driver-aware recommendations and normalize from inputs.
   - DriverCapabilities: feature flags per driver (jsonb, uuid native, binaryuuid viability, functional index limits).
   - TypeResolver: normalize/validate types (aliases + TypeFactory/custom); reuse Feature 4 logic.

2) Add persistence and headers
   - ConfigRepository: read/write plugins/Eav/config/eav.json; merge with CLI/map; update rawSql pointer after write.
   - HeaderBuilder: compose consistent headers (used in both migration and raw SQL outputs).

3) Factor generation into services
   - MigrationBuilder: move [buildMigration](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#buildMigration) logic; accept SetupConfig; return full PHP payload (string).
   - SqlGenerator: move [buildRawSql](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#buildRawSql); accept SetupConfig; return SQL string; keep Postgres/MySQL guards.

4) Output writers
   - OutputWriter: centralize path resolution and naming (migrations/Sql). Move [migrationPath](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#migrationPath), [nextMigrationFilename](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#nextMigrationFilename), [sqlOutputPath](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#sqlOutputPath), [nextSqlFilename](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#nextSqlFilename) into this class.

5) Orchestration and interactive prompts
   - WizardPrompter: encapsulate all ask* methods; return a SetupConfig; remains driver-aware and handles JSON Storage per-table mapping + optional index prompts.
   - SetupOrchestrator: given a SetupConfig, build generation payload (migration or SQL), prepend header, write files through OutputWriter, and persist eav.json via ConfigRepository (including rawSql pointer).

6) Refactor commands to the service
   - [EavSetupInteractiveCommand#runInteractive](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupInteractiveCommand.php#runInteractive): use WizardPrompter + Orchestrator; remove direct filesystem and build calls.
   - [EavSetupCommand#execute](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php#execute): parse options/--config; create SetupConfig; call Orchestrator; retain magic interactive launch gate.

7) Deprecations and BC
   - Keep public helpers in [EavSetupCommand](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavSetupCommand.php) as shims that delegate to service (resolveSelectedTypes, buildMigration, buildRawSql, path methods). Add @deprecated tags and removal note for the next major plugin release.
   - Ensure outputs are byte-for-byte compatible with Feature 4 (headers, filenames, directory structure).

8) Tests (part of this feature)
   - Unit tests for SetupDefaults, TypeResolver, DriverCapabilities, ConfigRepository, HeaderBuilder, MigrationBuilder, SqlGenerator, OutputWriter.
   - Command tests remain; update to assert commands call through and produce same outputs (dry-run assertions unchanged).
   - Add minimal WizardPrompter tests with stubbed IO (no full interactive flow; full interactive tests remain slated for Feature 8).

9) Docs/plan updates
   - Update PLAN and README (later feature) to describe the service layer and note deprecations on command helpers.

Rejected options (and why)
- Trait-based sharing:
  - Pros: Fastest; no object graph overhead.
  - Cons: Encourages duplication and poor encapsulation; hard to test in isolation. Rejected due to maintainability.
- Subcommand/task-based shell composition:
  - Pros: Natural split per concern (ask/generate/write).
  - Cons: Still couples logic to Console stack; test isolation remains weaker vs service classes. Rejected in favor of pure services.

Risks and mitigations
- Regression risk during extraction:
  - Mitigation: Build high-coverage unit tests around service components; keep command tests intact; migrate incrementally (interactive command → non-interactive).
- Divergence risk (commands vs service):
  - Mitigation: Commands call the Orchestrator exclusively; remove duplicated logic from commands (or leave as deprecated proxies).
- Environment differences (WSL paths, write permissions):
  - Mitigation: OutputWriter returns detailed results; commands present friendly messages; dry-run modes stay deterministic.

Milestones
- M1: Introduce SetupConfig, SetupDefaults, DriverCapabilities, TypeResolver; unit tests.
- M2: Add ConfigRepository, HeaderBuilder; unit tests.
- M3: Extract MigrationBuilder and SqlGenerator; OutputWriter; unit tests.
- M4: Add SetupOrchestrator and WizardPrompter; refactor Interactive command; pass tests.
- M5: Refactor non-interactive command to Orchestrator; deprecation shims; pass all tests.
- M6: Documentation update (in Feature 10).

Runbook (unchanged for users)
- Interactive: bin/cake eav setup (magic) or bin/cake eav setup:interactive
- Non-interactive: bin/cake eav setup --config plugins/Eav/config/eav.json --output migrations|raw_sql --dry-run
- Apply migrations: bin/cake migrations migrate -p Eav -c <connection>

Acceptance (for Feature 11)
- Commands delegate exclusively to the service layer (no business logic retained in commands).
- Byte-for-byte identical outputs for the same inputs compared to Feature 4 (headers, filenames, layout).
- eav.json persistence and rawSql pointer updates are performed by ConfigRepository.
- Public helper methods on EavSetupCommand exist as shims and are marked deprecated.
- Unit tests cover new service components; command tests remain green without changes to their assertions.
