# EAV Plugin 5.x Migration & Feature Plan (Source of Truth)

This file is the living, versioned plan for upgrading and evolving the EAV plugin. Do not diverge from this plan without updating this file via PR.

Version: v1.0 (initial consolidated plan)
Owner: ProtechPartsApp Persona
Scope: CakePHP 2.x to 5.x migration (no changes to 2.x), full TypeFactory coverage, interactive setup, DB-agnostic behavior, and UI scaffolding.

High-level principles
- Single family of EAV value tables per install (no PK suffix in table/table-class names).
- Canonical naming:
  - Tables: eav_<type> (e.g., eav_string, eav_json, eav_decimal, eav_fk).
  - PHP Tables: Eav<Model>Table (e.g., EavStringTable, EavJsonTable).
- Field names:
  - Always use entity_id (UUID or INT based on setup selection).
  - Use value (not val) for the attribute’s stored value column.
- Full TypeFactory coverage with sensible defaults; advanced types are opt-in during setup.
- Interactive Setup Command: prompt for connection, PK type, UUID subtype (if uuid), JSON column storage (json/jsonb guarded by driver), output mode (Migrations or raw SQL), jsonEncodeOnWrite, and type selection (defaults + optional).
- DB-agnostic by default; detect default datasource/driver; guard Postgres-only features automatically.
- Configuration persistence: save setup answers to a durable configuration (file and/or DB), and stamp migrations/SQL with the chosen settings.

Glossary
- JSON Attribute: an attribute whose data_type is json, stored in eav_json.value (column type json/jsonb per DB/choice).
- JSON Storage (Entity JSON bundle): storing all attributes for a single entity row in one JSON/JSONB column in the entity’s own table (e.g., engines.attrs, parts.spec). This is a storage mode alternative to typed EAV tables and is configured per application table via behavior options.

Formatting Guidelines
- Single-block-per-file MUST
- Use a single SEARCH/REPLACE block per edited file
- No mixed full-file + search/replace in the same message
- No split/continued blocks; ask to continue if too large
- Add a short mirror in Instructions:
- “Follow the Formatting Guidelines; they are mandatory.”

Feature 1 — Cleanup/Hardening (Done)
What’s drifting
- Value tables and classes currently use Av* and pk suffixes (e.g., av_string_uuid/av_string_int) and class resolution uses pk suffixes: see [EavBehavior#avTableClass](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#avTableClass) and [EavBehavior#pkSuffix](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#pkSuffix).
- JSONB naming drift in class/name composition (Json vs Jsonb): [EavBehavior#tableTypeSegment](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#tableTypeSegment).
- Static SQL snapshots under config/Migrations don’t align with canonical direction.

Realignment
- Adopt canonical naming: eav_* tables and Eav* tables classes (no pk suffix).
- Unify entity_id for both PK families; integer PK uses integer type for entity_id.
- Rename val column to value in all schemas, models, and behavior code.
- Remove config/Migrations/*.sql legacy snapshots. All schema is generated by Setup (Migrations or raw SQL).
- Configuration persistence (Setup answers):
  - Preferred: plugins/Eav/config/eav.json (JSON file) with all choices (connection, pkType, uuidSubtype, jsonStorage, jsonEncodeOnWrite, selected types, output mode).
  - Optionally: eav_settings table for multi-node deployments; not required initially.
  - Stamp generated migrations/SQL with a header comment summarizing chosen options.

Acceptanced
- Behavior resolves to Eav* classes and eav_* tables.
- Entity ID field is always entity_id; column type matches configured PK family.
- Value column is value across all code and schema.
- No dependency on Av* names or *_uuid/_int tables.

Summary and Confirmation
- Summary of changes for Feature 1 (Cleanup/Hardening)
  Behavior updates
  Canonical naming and resolution implemented in EavBehavior:
  avTableClass resolves to Eav* classes mapped to eav_* tables (no PK suffix dependency).
  Unified entity ID field via entityIdField to always use entity_id (type varies by PK family).
  Switched from val to value across reads/writes (saveEavValue, fetchEavValues, findByAttribute).
  JSON naming canonicalized to the “Json” segment; added jsonEncodeOnWrite gating for write-time JSON encoding.

- Setup command hardening
  Canonical schema generation in EavSetupCommand:
  Generates eav_* tables (e.g., eav_string, eav_json).
  Always uses entity_id; column type based on configured PK family (UUID subtype or BIGINT).
  Uses value column consistently; eav_json.value uses json or jsonb per driver and choice.
  Limits default scaffolded types to a safe baseline; advanced/geospatial types deferred to Feature 2.
  Migration naming conflict guidance given; resolved by removing the older migration or using a unique --name.
  JSONB migrator fixes

- EavMigrateJsonbToEavCommand:
  Replaced the Postgres “?” operator with jsonb_exists(...) to avoid PDO “?” placeholder conflicts.
  Continues to guard for Postgres-only features and uses the behavior to persist EAV values.
  Added files (new)
  EavStringTable.php: Maps to eav_string.
  EavJsonTable.php: Maps to eav_json.
  EavStringFixture.php: eav_string with value column.
  EavJsonFixture.php: eav_json with value column.

- Modified files
  EavBehavior.php: Canonical resolution, unified entity_id, value column, JSON gating.
  EavSetupCommand.php: Canonical eav_* tables, entity_id, value column; safe default types.
  EavMigrateJsonbToEavCommand.php: jsonb_exists fix for queries.
  EavBehaviorTest.php: Updated fixtures to Eav*; added setUpBeforeClass to ensure attributes, eav_string, and eav_json exist in test DB; expectations updated for canonical JSON class resolution and value column.
  EavSetupCommandTest.php: Verifies dry-run output and presence of attributes/attribute_sets in migration.
  EavMigrateJsonbToEavCommandTest.php: Adjusted TRUNCATE to include attribute_set_attributes and CASCADE to satisfy FK constraints, and updated to eav_string/value. (File not shown above, but this change was applied during test stabilization.)

- Deleted files (by you)
  Legacy Av* Table classes under plugins/Eav/src/Model/Table (e.g., AvStringUuidTable.php, AvJsonUuidTable.php, AvStringIntTable.php, etc.).
  Legacy Av* fixtures under plugins/Eav/tests/Fixture.
  Legacy SQL snapshots under plugins/Eav/config/Migrations/*.sql.
  What intentionally remains unchanged in Feature 1
  Core tables for attributes and sets remain unprefixed: attributes, attribute_sets, attribute_set_attributes. Prefixing and junction model conventions are planned for Feature 5 per PLAN.md.

- Commands used during this work
  Generate migration for test connection:
  bin/cake eav setup --pk-type uuid --uuid-type uuid --json-storage json --connection test
  Apply plugin migrations to test DB:
  bin/cake migrations migrate -p Eav -c test
  Run PHPUnit test suites:
  vendor/bin/phpunit plugins/Eav/tests
  vendor/bin/phpunit plugins/Eav/tests/TestCase/Model/Behavior/EavBehaviorTest.php
  vendor/bin/phpunit plugins/Eav/tests/TestCase/Command/EavSetupCommandTest.php
  vendor/bin/phpunit plugins/Eav/tests/TestCase/Command/EavMigrateJsonbToEavCommandTest.php
  Outcome
  All Feature 1 acceptance criteria are met: Behavior/table resolution is canonical (Eav*/eav_), entity_id is unified, value column is consistent, and Av dependencies and legacy SQL snapshots are removed. Prefixing of core attribute/attribute set tables is deferred to Feature 5 as planned.

Confirmation against acceptance
  - "Behavior resolves to Eav* classes and eav_* tables: Yes.
  Class resolution via avTableClass now returns Eav.* classes (no PK suffix) and canonicalizes JSON to EavJson.
  Corresponding Eav* Table classes are in place (tests passed), so resolution maps to eav_* tables correctly.
  Entity ID field is always entity_id; type matches PK family: Yes.
  Behavior returns entity_id from entityIdField.
  Setup generates entity_id with the proper type in buildMigration (UUID subtype or BIGINT).
  Value column is value across all code and schema: Yes.
  Behavior writes/reads value in saveEavValue, fetchEavValues, and findByAttribute.
  Setup generates value columns in buildMigration.
  No dependency on Av* names or *_uuid/_int tables: Yes.
  Av* classes/fixtures were removed by you; tests use Eav* and eav_* exclusively and now pass.
  JSONB migrator fixed to avoid “?” placeholder issues using jsonb_exists() in execute.
  Static SQL snapshots removed: Yes (you deleted them).
  Notes/deferrals per PLAN
  Attributes/AttributeSets tables remain unprefixed and the join table remains attribute_set_attributes by design; prefixing is scheduled in Feature 5 (see plugins/Eav/PLAN.md).
  Configuration persistence to plugins/Eav/config/eav.json and interactive setup are planned for Feature 4; not required in Feature 1."

Feature 2 — Data Type Support
Goals
- Support all CakePHP TypeFactory types + custom ‘fk’.
- Default set most apps need; advanced types are opt-in via interactive Setup.
- Single eav_fk table: value type depends on PK family (UUID subtype or BIGINT), but name and schema remain canonical.

Defaults (pre-selected in Setup)
- string, text, integer, smallinteger, tinyinteger, biginteger, decimal, float, boolean, date, datetime, time, json, uuid, binaryuuid, nativeuuid, fk

Optional/Advanced (opt-in during Setup)
- char, binary, enum (string-limited), timestamp, datetimefractional, timestampfractional, timestamptimezone
- geometry, point, linestring, polygon (only if DB/extension supports)
Notes:
- All selected types get a dedicated table Eav* + eav_<type>. For rare/custom types not selected, dynamic tables are supported but documented as possibly less performant.

Acceptance
- Setup scaffolds only the selected set (defaults + optional).
- [EavBehavior#isSupportedType](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#isSupportedType) validates using TypeFactory + custom types.

Summary and Confirmation
  - Summary of work completed for Feature 2 (Data Type Support + single eav_fk)
      - Goals met:
        - Unified custom foreign key type to fk with a single canonical eav_fk table; value type follows chosen PK family (uuid subtype or biginteger).
        - Setup command now scaffolds only selected types (defaults/all/CSV via --types) with TypeFactory validation and alias normalization (e.g., fk_uuid/fk_int -> fk).
        - Behavior validates types via TypeFactory plus custom types, resolves tables dynamically when no Eav*Table class exists, and casts fk according to pkType.
        - JSONB migration command hardened with connection selection, source-table existence guard, and jsonb_exists filter.

  - Key changes
    - Setup generator
    - Added --types selection and alias normalization; defaults exclude timestamp (advanced types remain opt-in).
    - Special-cased fk to emit eav_fk with PK-family value type.
    - For json, always uses eav_json; column type is json or jsonb per driver/flag.
    - Updated generator to emit addTimestamps('created','modified') for all eav_* tables to prevent NOT NULL violations when dynamic tables are used without a Timestamp behavior. Regenerate your migration via the command to apply this.

  - Behavior
    - Added back-compat aliases fk_uuid/fk_int -> fk and support for unified fk in casting.
    - Dynamic fallback in table resolution (uses a generic Table targeting eav_  when no Eav*Table class exists).
    - Validation through TypeFactory map and custom 'fk'.

  - JSONB migrator
    - Added --connection flag and consistent use for reads/writes.
    - Guards: Postgres-only, verifies source table exists on connection with a clear error if missing.
    - Uses jsonb_exists with ::jsonb cast for json columns; saves using normalized types.

  - Tests
    - Added/used JsonEntitiesFixture for source data; stabilized EavMigrateJsonbToEavCommandTest to operate on the test datasource and json_entities table.
    - Kept setUpBeforeClass bootstraps where other tests depend on schema presence; added missing TableSchema import.
    - All tests pass.

  - Files touched
    - Commands
      - EavSetupCommand.php --types option (defaults|all|CSV); resolveSelectedTypes; fk special-casing in buildMigration; json storage handling; addTimestamps in eav_* loop.
      - EavCreateAttributeCommand.php normalizeType: jsonb->json; fk_uuid/fk_int->fk; TypeFactory validation.
      - EavMigrateJsonbToEavCommand.php --connection option; connection-aware table access; source table existence check; jsonb_exists with ::jsonb cast; saves using normalized type.

  - Behavior
    - EavBehavior.php
      - typeAliases includes fk_uuid/fk_int -> fk; customTypes includes fk; isSupportedType uses TypeFactory; tableFor dynamic fallback; castValueForType handles fk by pkType.

  - Tables/Entities (no structural changes beyond existing)
    - EavStringTable.php, EavJsonTable.php AttributesTable.php, Attribute.php

  - Tests and fixtures
    - JsonEntitiesFixture.php (source json_entities table)
    - AttributesFixture.php, EavStringFixture.php, EavJsonFixture.php
    - EavMigrateJsonbToEavCommandTest.php (uses test connection and json_entities; added TableSchema import; kept setUpBeforeClass)
    - EavCreateAttributeCommandTest.php, EavSetupCommandTest.php
    - EavBehaviorTest.php

  - Migration
    The latest committed migration file exists: config/Migrations/20251221070031_eav_setup.php. After updating the generator (EavSetupCommand), regenerate a new migration so eav_* tables use addTimestamps in the loop.

  - Commands executed and expected
    - Setup (dry-run):
      - bin/cake eav setup --dry-run --pk-type uuid --uuid-type uuid --json-storage json --connection test

  - Apply migrations to test DB:
    - bin/cake migrations migrate -p Eav -c test
  - JSONB migrator (test):
    - bin/cake eav migrate_jsonb_to_eav json_entities data --attribute color --type string --dry-run --connection test
    - bin/cake eav migrate_jsonb_to_eav json_entities data --attribute color --type string --connection test

  - PHPUnit:
    - vendor/bin/phpunit plugins/Eav/tests (or targeted files as needed)

  - Schema and configuration updates
    - Generator now emits addTimestamps for all eav_* tables (attributes and set tables already used addTimestamps). Regenerate the migration via the setup command; avoid hand-editing generated files.
    - Unified single eav_fk table; canonical eav_* names used throughout.
    - Optional: Refresh schema-dump lock files to remove legacy av_* and fk_uuid/fk_int artifacts for clarity.

  - PR checklist (per AGENTS.md)
    - Work completed:
      - fk unification, type selection via --types in setup, generator emits addTimestamps in eav_* loop, behavior validation and dynamic resolution, JSONB migrator connection handling and guard.

    - Commands executed:
      - As listed above (setup dry-run, migrations migrate -p Eav -c test, JSONB migrator, PHPUnit).

    - Table counts added:
      - Verified in tests (e.g., EavMigrateJsonbToEavCommandTest asserts 1 migrated value in write flow), and unique index present on (entity_table, entity_id, attribute_id).
    - Schema/config changes:
      - Canonical eav_* schema; addTimestamps in generator; one eav_fk.

Feature 3 — JSON
  - Scope
    - Postgres-only for this feature.
    - Engines uses attrs (jsonb), Parts uses spec (jsonb). For the plugin in general, the JSON column name must be configurable per table.
    - Keep JSON Attribute (eav_json.value) fully supported, but distinct from JSON Storage Mode. We’ll avoid conflating them.

  - Behavior: JSON Storage Mode
    - Enable via EavBehavior config on an application table: ['storage' => 'json_column', 'jsonColumn' => 'attrs'] or ['jsonColumn' => 'spec'].
    - Query rewriting: In beforeFind, detect conditions/order/selects that reference EAV attribute names and emit Postgres JSONB expressions:
      - string: (attrs->>'color') = 'red'
      - numeric: ((attrs->>'year_start')::int) >= 2010
      - boolean: ((attrs->>'is_active')::boolean) = true
      - dates/times: cast using appropriate types when we can resolve type (see “Type resolution”)

    - Projection as native fields: Inject expressions into SELECT so attributes appear as real entity properties (e.g., SELECT ((attrs->>'year_start')::int) AS year_start). Hydration type-corrected in afterFind via TypeFactory to guarantee PHP-native types for app use.
    - Magic finders: Cake’s magic finders work because conditions are rewritten (e.g., findByColor, findByYearStart).
    - Efficient writes: In [beforeSave]/write helpers (file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#saveEavValue), update single keys via jsonb_set instead of rewriting the entire JSON document. Support remove via attrs - 'key'. Parameterize and cast to jsonb correct types.
    - Indexing guidance:
    - GIN: CREATE INDEX ON engines USING GIN (attrs);
    - Functional: CREATE INDEX ON engines (((attrs->>'year_start')::int)); CREATE INDEX ON engines ((attrs->>'color'));
    - We’ll document these and optionally add helper generation later.

  - Type resolution strategy (to satisfy “typed primitives” without mandatory registry)
    - Priority order:
    - attributeTypeMap (behavior option): name => type. Quick, explicit, optional.
    - Attributes table registry: if present for name, use data_type (preferred for precision).
    - Automatic inference:
      - If the JSON value is numeric (actual JSON number), treat as integer/float depending on presence of decimal point/precision of comparison value.
      - If the JSON value is true/false, treat as boolean.
      - If a query condition is passed a Date/DateTime/Time object, cast accordingly in SQL (date, timestamp, time).
      - If the condition value is a scalar and matches unambiguous date/time patterns, we can cast cautiously (opt-in toggle to avoid over-eager inference).
      - Otherwise, default to string.
      - Caching: We’ll cache resolved types by attribute name per-table to avoid repeated lookups during a request.
      - Result: Numeric and boolean fields are reliably typed without a registry. Date/time achieve correctness if either the type map/registry exists or the query supplies typed values (e.g., where(['manufactured_at >=' => FrozenDate::today()])).

  - JSON Attribute vs JSON Storage Mode
    - JSON Attribute: data_type=json stored in eav_json.value. Existing behavior continues. jsonEncodeOnWrite applies here (and only here).
    - JSON Storage Mode: All attributes live in a single JSONB column (attrs/spec). No eav_json table needed. jsonEncodeOnWrite must be ignored here to prevent double-encoding; we will gate its use by storage mode.
    - Default: storage => 'tables'. Apps opt-in to JSON Storage Mode per entity table.

  - Setup Command and configuration
    - Today:
      - EavSetupCommand remains responsible for EAV tables (including eav_json.value json/jsonb). Keep --json-storage for JSON Attribute (we’ll document the naming to avoid confusion).
      - New in Feature 3 (lightweight addition, no schema changes to app tables automatically):
      - We’ll add support to declare JSON Storage Mode targets in the behavior config (per Table) and document how to add/ensure the JSONB column exists in your entity table (attrs/spec).
      - In a later feature, the command can optionally:
      - Prompt for JSON Storage Mode per app table and column name(s).
      - Generate migrations to add jsonb columns if missing (e.g., engines.attrs jsonb default '{}'::jsonb not null).
      - Column names for ProtechParts:
      - engines: attrs (jsonb)
      - parts: spec (jsonb)
      - We’ll use these in tests for this feature; behavior config will allow per-table override for other apps.
  - jsonEncodeOnWrite default
    - Set default to false globally.
    - Behavior will respect jsonEncodeOnWrite only in “tables storage” for JSON Attribute (eav_json). In JSON Storage Mode, it is ignored to prevent double-encoding. This preserves expectations and avoids regressions.

  - Do we require attributes to be created?
    - Not required in JSON Storage Mode. We support three resolution paths:
    - attributeTypeMap (explicit)
    - attributes registry (preferred for precision when available)
    - automatic inference for numbers/booleans; date/time when the condition value is typed or matches strict patterns.
    - Optional setting: autoRegisterUnknownAttributes (future): on save, automatically create missing attributes with inferred type for long-term consistency. Disabled by default; discuss later if desired.

  - Performance and storage: entity JSON column vs single “bundle table”
    - Option A: Entity table JSONB column (current approach; e.g., engines.attrs, parts.spec)
      - Pros:
        - No joins for attribute queries; simpler SQL and ORM integration.
        - Atomic updates via jsonb_set allow writing a single key without rewriting the entire document.
        - Functional indexes per “hot” attribute are straightforward:
          - Example: CREATE INDEX ON engines (((attrs->>'year_start')::int))
          - Example: CREATE INDEX ON engines ((attrs->>'color'))
        - GIN index on the column accelerates key existence/containment:
          - Example: CREATE INDEX ON engines USING GIN (attrs)
        - Operationally simple: one table to manage, fewer joins to tune.
      - Cons:
        - Every entity table carries the JSONB column even if sparse.
        - Duplicate index strategies may be needed per entity table if many tables use JSON Storage Mode.
        - Frequent attribute updates can increase write amplification and MVCC bloat on the main table (monitor VACUUM).
      - Postgres storage/size notes:
        - Prefer allowing NULL for sparse usage to avoid per-row “{}” overhead; coalesce in projections when needed.
        - Large JSONB values are TOASTed; if the column isn’t selected, Postgres won’t fetch the out-of-line value.
        - HOT updates are more likely to break if the JSONB column changes frequently; keep an eye on bloat and autovacuum settings.

    - Option B: Dedicated “bundle” table (plugin-managed), e.g., eav_bundle(entity_table, entity_id, data jsonb)
      - Pros:
        - Naturally sparse: only rows with attributes exist—no overhead in base tables.
        - Isolates churn: heavy attribute updates don’t bloat the main entity tables; reduces lock/contention on hot entities.
        - Centralized indexing: maintain one GIN index plus functional indexes scoped by entity_table.
        - Easier to archive or partition attribute data separately.
      - Cons:
        - Requires a join in every attribute query; more complex query rewriting and planning.
        - Still likely to maintain both a GIN index and multiple functional indexes (now on the bundle table).
        - Slightly more complex behavior logic and migrations.

    - Rule of thumb (Postgres):
      - If most rows have attributes and attribute reads/filters are common → use the entity JSONB column for simplicity and speed (zero joins).
      - If attributes are sparse or attributes change very frequently/are very large → use the dedicated bundle table to reduce base-table bloat and contention.
      - In either case, add:
        - GIN index on the JSONB document when you need containment/existence.
        - Targeted functional indexes for hot keys (cast to the correct type: int, boolean, date, etc.).

    - Recommendation for ProtechParts (current state):
      - Keep entity JSON column mode (attrs/spec) for Feature 3, as it’s already in use and avoids extra joins.
      - Allow NULL for the column (avoid default '{}'::jsonb) to reduce storage for sparse rows; COALESCE in projections if necessary.
      - Add a GIN index and targeted functional indexes (e.g., year_start, color) based on actual query patterns.
      - Reassess if update churn or table bloat becomes significant—then consider introducing a dedicated “json_side_table” backend.

    - Forward compatibility:
      - We can add a “json_side_table” storage backend later and make storage selectable per table via behavior config.
      - The behavior design will keep storage backends pluggable so switching is safe and requires minimal app changes.

  - Tests (specific to JSON Storage Mode)
    - Add fixtures for:
    - engines: id uuid, attrs jsonb
    - parts: id uuid, spec jsonb

  - Test cases:
    - Magic finders and conditions on string: findByColor, where(['color ILIKE' => 're%'])
    - Numeric compare: where(['year_start >=' => 2010]), orderDesc('year_start')
    - Boolean: where(['is_active' => true])
    - Date/time: pass typed values (FrozenDate/FrozenTime) and verify correct filtering and hydration
    - Hydration types: ensure entity->year_start is int, entity->is_active is bool, entity->manufactured_at is Date/DateTime as applicable
    - Save single attribute updates JSON via jsonb_set
    - Keep existing JSONB → EAV migrator tests (json_entities fixture) for the other direction.
  - Documentation updates (summary)
   - Clarify terminology: “JSON Attribute” (eav_json) vs “JSON Storage Mode” (entity JSON column).
   - How to enable JSON Storage Mode in behavior with per-table jsonColumn.
   - Index recommendations (GIN + functional).
   - Supported operators and typed casting rules, including how automatic typing works and where hints are needed (dates/times).
   - Setup command notes: --json-storage is for JSON Attribute; JSON Storage Mode configuration is behavior-based (for now). Future: interactive prompts to add JSONB columns to specified app tables.

  - Acceptance for Feature 3
   - With ['storage' => 'json_column', 'jsonColumn' => 'attrs'|'spec']:
   - Magic finders and standard where/order clauses over EAV attribute names work in Postgres with correct types.
   - Entities expose EAV attributes as native properties with PHP-native types.
   - Writes use jsonb_set to update single keys atomically.
   - JSON Attribute (eav_json) behavior and setup are unaffected.
   - jsonEncodeOnWrite default false globally; ignored in JSON Storage Mode; still respected for JSON Attribute.

# Summary: Feature 3 – JSON Storage Mode (EAV in a single JSON/JSONB column)

## Overview
- Goal: Add a “JSON Storage Mode” to the EAV plugin so all attributes for an entity can be stored in a single JSON/JSONB column on the entity’s table (e.g., Items.attrs, Products.spec) while maintaining typed queries and CakeORM ergonomics.
  - Preserve existing “JSON Attribute” support (data_type=json in eav_json) and keep typed AV tables (eav_integer, eav_date, etc.) fully functional.

## What was implemented

### Behavior support
- Added JSON Storage Mode options and logic to the behavior:
    - `storage=json_column`, `jsonColumn=attrs|spec`
    - `attributeTypeMap` for typing hints per attribute
  - Projections and hydration
      - In `beforeFind`, the behavior:
          - Appends base table columns (so id and native columns remain available)
          - Projects JSON attributes as select aliases using Postgres JSONB extraction/casts
          - Registers the select type map for projected aliases so Cake hydrates as proper PHP-native types (date, float, int, bool)
  - Typed hydration
      - In `afterFind`, retained minimal deterministic casting as a safety net; primary typing is now via select type map (Cake-idiomatic)
  - Writes via jsonb_set
      - In `afterSave`, updates only changed keys using `jsonb_set`, via `Connection::updateQuery()` (CakePHP 5 API), with a proper `text[]` path cast. Null values remove keys.

### Postgres JSONB helpers
- New trait encapsulating JSONB expressions, parameter binding, and typing resolution:
    - `plugins/Eav/src/Model/Behavior/JsonColumnStorageTrait.php`
  - Key capabilities:
      - SELECT/ORDER projections inline JSON key as safe SQL literals (avoid binding issues for keys) while identifiers are quoted via driver
      - WHERE fragments are parameterized and use `jsonb_exists((col)::jsonb, :key)` to avoid conflicts with the `?` operator and maintain PDO compliance
      - Batch `jsonb_set` updates with path cast to `text[]` and DB-level casting of values (e.g., `to_jsonb(:v::int)`)

### Tests
- New generic plugin fixtures/tables for JSON Storage Mode:
    - `plugins/Eav/tests/Fixture/ItemsFixture.php` (items.attrs JSON)
    - `plugins/Eav/tests/Fixture/ProductsFixture.php` (products.spec JSON)
    - Existing domain-y fixtures (Engines/Parts) remain in repo but tests use generic Items/Products
  - JSON Storage Mode test case validates:
      - String/numeric/boolean queries via safe JSONB expressions
      - Ordering by projected alias (typed)
      - Null semantics (missing key)
      - Hydration types: date → `Cake\I18n\Date`; float/int/bool → native PHP types
      - `jsonb_set` partial updates on save
  - Cake 5 compatibility in tests:
      - Use `Cake\Database\Expression\QueryExpression` (not ORM namespace)
      - Use `orderByAsc`/`orderByDesc` (replacing deprecated `orderAsc`/`orderDesc`)

### Migrations (tests)
- Plugin migration for test tables (if used in environment):
    - `plugins/Eav/config/Migrations/20251223000000_create_json_storage_test_tables.php`
  - Existing setup migrations for EAV tables remain:
      - `plugins/Eav/config/Migrations/20251221044219_eav_setup.php`
      - `plugins/Eav/config/Migrations/20251221093127_uuid_eav_setup.php`

## Key decisions and compliance notes
- PDO compliance:
    - WHERE and UPDATE values are bound as named parameters
    - Avoid Postgres `?` key-existence operator; use `jsonb_exists`
    - For SELECT/ORDER projections, JSON key (attribute name) is embedded as a safely quoted SQL literal; all values remain parameterized
  - CakePHP 5.x API usage:
      - Driver-based identifier quoting (`getDriver()->quoteIdentifier`)
      - `updateQuery()` for updates; `UpdateQuery::newExpr()` for raw expressions
      - Select type map for typed hydration
      - No `Connection::quote`/`quoteIdentifier`; removed `TableRegistry` usage in new code paths; use `getTableLocator()`
  - JSON Attribute vs JSON Storage Mode:
      - JSON Attribute (eav_json) continues to work unchanged
      - JSON Storage Mode is per-table via behavior config; no app schema changes are performed automatically by this feature

## Not included (future features)
- SetupCommand changes for JSON Storage Mode (interactive prompts/migrations for app columns/indexes) — planned future enhancement
  - Automatic condition rewriting for attribute names in plain ORM where/magic finders — to be added in a follow-up feature (tests currently use explicit JSONB expressions)

## Files created
- Behavior helper:
    - `plugins/Eav/src/Model/Behavior/JsonColumnStorageTrait.php`
  - Test fixtures (generic):
      - `plugins/Eav/tests/Fixture/ItemsFixture.php`
      - `plugins/Eav/tests/Fixture/ProductsFixture.php`
  - Test migration (optional in your environment):
      - `plugins/Eav/config/Migrations/20251223000000_create_json_storage_test_tables.php`
  - Test case:
      - `plugins/Eav/tests/TestCase/Model/Behavior/EavJsonStorageModeTest.php`

## Files modified
- Behavior core:
    - `plugins/Eav/src/Model/Behavior/EavBehavior.php`
  - Fixtures/tests (updated or referenced):
      - `plugins/Eav/tests/Fixture/EavStringFixture.php`
      - `plugins/Eav/tests/Fixture/EavJsonFixture.php`
      - `plugins/Eav/tests/TestCase/Model/Behavior/EavBehaviorTest.php`
      - `plugins/Eav/tests/TestCase/Command/EavSetupCommandTest.php`
  - Migrations (existing EAV setups retained/used as-is):
      - `plugins/Eav/config/Migrations/20251221044219_eav_setup.php`
      - `plugins/Eav/config/Migrations/20251221093127_uuid_eav_setup.php`

## Runbook
- Apply plugin migrations on test connection (if using test migration):
    - `bin/cake migrations migrate -p Eav -c test`
  - Run plugin tests:
      - `vendor/bin/phpunit plugins/Eav/tests`

## Acceptance/Outcomes
- JSON Storage Mode is available and tested on Postgres:
    - Entities expose JSON attributes as native fields with correct PHP types
    - Queries and ordering supported via Postgres JSONB expressions with proper DB casts
    - Saves update only changed keys via `jsonb_set` with `text[]` path
  - Existing JSON Attribute and typed AV table paths remain intact

## Follow-ups recommended
- Implement automatic condition rewriting in EavBehavior (beforeFind) for magic finders and plain `where(['attr >' => 10])` without raw expressions
  - SetupCommand enhancements for JSON Storage Mode:
      - Interactive prompts per table/column
      - Optional migrations to add JSONB columns and indexes (GIN + functional)
  - Documentation refresh in README for JSON Storage Mode and indexing recommendations

Feature 4 — Setup Command (Interactive)
  Goals
- Interactive prompts with safe driver-based defaults; minimal flags (flags remain for CI).
- Prompt flow:
  1) Connection (default datasource; prompt only if multiple).
  2) Output: Cake Migrations (phinx) or raw SQL.
  3) PK family: uuid or int.
     - If uuid: UUID subtype (Recommended varies by driver)
       - Postgres: nativeuuid (Recommended)
       - MySQL/MariaDB: binaryuuid (Recommended)
       - SQL Server: nativeuuid (Recommended)
       - SQLite: uuid (string) (Recommended)
  4) JSON column storage: json or jsonb (jsonb only on Postgres).
  5) jsonEncodeOnWrite: yes/no (default yes).
  6) Types to scaffold: defaults pre-selected; advanced types selectable.
  7) Confirm and generate.
- Schema specifics for all eav_* tables:
  - id: UUID (row id)
  - entity_table: string(191)
  - entity_id: type depends on PK family (uuid subtype or biginteger)
  - attribute_id: UUID
  - value: column type per eav_<type> (json/jsonb for json)
  - created, modified: DB default CURRENT_TIMESTAMP or addTimestamps (migrations)
  - Unique index: (entity_table, entity_id, attribute_id)
  - FK: attribute_id -> eav_attributes.id (ON DELETE CASCADE)

Migrations and SQL
- If Migrations: use addTimestamps for created/modified (safe even without Table classes).
- If SQL: generate driver-specific SQL with appropriate column types and timestamp defaults.
- Write chosen options as a header comment; persist the full selection in plugins/Eav/config/eav.json.

Acceptance
- Running “bin/cake eav setup” interactively generates a migration or SQL with canonical naming, unified entity_id, and value column.

Feature 5 — EavEntities / EavAttributes / EavAttributeSets
Goals
- Prefix model classes and tables to avoid collisions and keep grouping.
  - Tables: eav_entities, eav_attributes, eav_attribute_sets, eav_attribute_set_attributes
  - Classes: EavEntitiesTable, EavAttributesTable, EavAttributeSetsTable, EavAttributeSetAttributesTable
- Associations:
  - EavAttributes belongsToMany EavAttributeSets through EavAttributeSetAttributes.
  - EavAttributeSets belongsToMany EavAttributes through EavAttributeSetAttributes.
  - EavEntities is a registry of app entities; explicit hasMany to typed values is not modeled (values live in multiple typed tables). The Behavior provides the entity-aware access to values.
- Validation: names required/unique, label lengths, Timestamp behavior across all.

Acceptance
- Bake CRUD for EavAttributes, EavAttributeSets, EavAttributeSetAttributes, and EavEntities.

Feature 6 — Command connection handling
- Auto-detect default datasource; prompt if multiple.
- Keep optional flags for CI but not required for interactive use.
- Maintain Postgres guard for JSONB in [EavMigrateJsonbToEavCommand#execute](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Command/EavMigrateJsonbToEavCommand.php#execute).

Feature 7 — Behavior consistency and finder
- Update resolution to canonical Eav* classes and eav_* tables (no pk suffixing).
  - [EavBehavior#tableTypeSegment](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#tableTypeSegment)
  - [EavBehavior#avTableClass](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#avTableClass)
  - [EavBehavior#tableFor](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#tableFor)
- Keep unified [EavBehavior#entityIdField](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#entityIdField) as entity_id.
- Expand [EavBehavior#findByAttribute](file:///home/paul/dev/cakephp/protech_parts/plugins/Eav/src/Model/Behavior/EavBehavior.php#findByAttribute) using ORM expressions; avoid hard-coded SQL operators outside Postgres specifics. Most consumers will use Cake’s magic finders (e.g., findByName).

Feature 8 — Tests
- Rename fixtures from av_* to eav_*; switch ‘val’ to ‘value’; ensure unified entity_id across fixtures.
- Update tests that assumed AvJsonbUuid class naming (canonicalize to EavJson).
- Add tests for interactive Setup (simulated answers), UUID subtype recommendations, and type selection.
- Add CRUD tests for EavAttributes/EavAttributeSets/EavEntities.
- Add regression coverage for jsonEncodeOnWrite true/false.

Feature 9 — UI scaffolding (bake)
- Bake CRUD for:
  - EavAttributes
  - EavAttributeSets
  - EavAttributeSetAttributes
  - EavEntities
- Basic forms for adding attributes and organizing sets per entity.
- Controller/View route naming can follow plugin defaults; no additional “Eav” prefix in URLs is required beyond the plugin name (Eav).

Feature 10 — Documentation
- Rewrite README with:
  - Overview and capabilities (no 2.x migration notes).
  - Setup walkthrough (interactive prompts) with examples.
  - Supported types: default vs optional; geospatial caveats.
  - UUID subtype recommendations by driver.
  - jsonEncodeOnWrite and hydration expectations.
  - Behavior attachment and mapping examples.
  - AttributeSets and EavEntities usage.
  - Raw SQL vs Migrations options.
- Maintain a CHANGELOG for notable plan/architecture changes.

Storage modes and when to choose which
- Typed EAV tables (“tables” storage, default):
    - Best when attributes are shared across many entities, you need per-attribute constraints/joins, or DB portability matters.
    - Sparse storage by nature (no empty columns); joins add complexity, but behavior makes fields feel native.
- JSON Storage (entity JSON column, Postgres-only in Feature 3):
    - Best when most rows have attributes and you want zero joins with transparent ORM integration.
    - Use functional indexes per “hot” attribute and a GIN index on the JSONB column.
    - Allow NULL for sparse tables to avoid per-row “{}” overhead; coalesce in projections as needed.
- Clear terminology in Setup:
    - “JSON Attribute column type” is the json/jsonb choice for eav_json.value.
    - “Storage mode” determines whether attributes live in typed EAV tables (default) or in an entity JSONB column (JSON Storage Mode).
    -
Deprecations and removals
- Remove config/Migrations/*.sql legacy snapshots (regenerate via Setup).
- Remove Av* classes and av_* fixtures as we migrate; no TableLocator alias needed. Replace all usage with Eav* and eav_*.

Risks and mitigations
- Naming/schema migration: handled via Setup regeneration and clear upgrade notes.
- JSONB availability: guard on Postgres; fall back to JSON elsewhere with a notice.
- Advanced types by driver: warn/skip when unsupported; allow opt-in explicitly.
- Interactive setup in CI: flags remain available for non-interactive runs.

Immediate actionable checklist
- Behavior:
  - Canonicalize to Eav* classes and eav_* tables.
  - Unify entity_id naming and column usage (remove entity_int_id).
  - Rename val -> value across behavior, commands, and tests.
  - Add jsonEncodeOnWrite config and gate JSON encoding.
- Setup:
  - Convert to interactive prompts; add connection detection and driver-based defaults.
  - Generate Migrations or raw SQL; eav_* names; entity_id; value column; timestamp defaults.
  - Persist chosen config to plugins/Eav/config/eav.json; stamp migration/SQL comments.
  - Allow type selection (defaults + optional).
- Commands:
  - Keep Postgres guard in JSONB migrator.
  - Use detected default connection; prompt if multiple; allow flag for CI.
- ORM:
  - Add EavEntities, EavAttributes, EavAttributeSets, EavAttributeSetAttributes with associations and validation.
  - Generate Eav* value tables for selected types, or provide a generator step.
- Tests:
  - Update fixtures, test names, and expectations to eav_* and value.
  - Add interactive setup tests; CRUD tests; jsonEncodeOnWrite tests.
- Docs:
  - Rewrite README; add CHANGELOG entry; cross-link to this PLAN.

Process & governance
- This PLAN.md is the source of truth. Update via PR in branches tied to JIRA tickets (1 feature per branch).
- AGENTS.md should link to this file and summarize status; AGENTS-VSCode.md remains deprecated.
- Per-feature conversation template (include in each chat):
  - Link to this plan: plugins/Eav/PLAN.md
  - JIRA issue key and scope
  - Target files to modify (paths)
  - Desired acceptance criteria and tests to add/update
  - Any special driver assumptions
- After each feature completes, add a short “Conversation Summary” back into this PLAN (or docs/features/FEATURE-<key>.md) with:
  - What changed (files, schema)
  - Commands run
  - Table counts or verifications
  - Follow-ups/TODOs

Driver-based UUID recommendations (used in Setup)
- Postgres: nativeuuid (Recommended)
- MySQL/MariaDB: binaryuuid (Recommended)
- SQL Server: nativeuuid (Recommended)
- SQLite: uuid (string) (Recommended)
